<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F24%2Fthymeleaf%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.Thymeleaf简介官方网站：https://www.thymeleaf.org/index.html Thymeleaf是用来开发Web和独立环境项目的现代服务器端Java模板引擎。 Thymeleaf的主要目标是为您的开发工作流程带来优雅的自然模板 - HTML。可以在直接浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。 借助Spring Framework的模块，可以根据自己的喜好进行自由选择，可插拔功能组件，Thymeleaf是现代HTML5 JVM Web开发的理想选择 - 尽管它可以做的更多。 Spring官方支持的服务的渲染模板中，并不包含jsp。而是Thymeleaf和Freemarker等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。 2.特点特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 3.环境准备我们来创建一个module，为学习Thymeleaf做准备： 3.1.创建module使用spring 脚手架创建： 勾选web和Thymeleaf的依赖： 项目结构： pom： &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;thymeleaf-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.2.默认配置不需要做任何配置，启动器已经帮我们把Thymeleaf的视图器配置完成： 而且，还配置了模板文件（html）的位置，与jsp类似的前缀+ 视图名 + 后缀风格： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html Thymeleaf默认会开启页面缓存，提高页面并发能力。但会导致我们修改页面不会立即被展现，因此我们关闭缓存： # 关闭Thymeleaf的缓存spring.thymeleaf.cache=false 另外，修改完毕页面，需要使用快捷键：Ctrl + Shift + F9来刷新工程。 3.3.快速开始我们准备一个controller，控制视图跳转： @Controllerpublic class HelloController &#123; @GetMapping("show1") public String show1(Model model)&#123; model.addAttribute("msg", "Hello, Thymeleaf!"); return "hello"; &#125;&#125; 新建一个html模板： &lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text="$&#123;msg&#125;"&gt;大家好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 启动项目，访问页面： 4.语法Thymeleaf的主要作用是把model中的数据渲染到html中，因此其语法主要是如何解析model中的数据。从以下方面来学习： 变量 方法 条件判断 循环 运算 逻辑运算 布尔运算 比较运算 条件运算 其它 4.1.变量变量案例我们先新建一个实体类：User public class User &#123; String name; int age; User friend;// 对象类型属性&#125; 然后在模型中添加数据 @GetMapping("show2")public String show2(Model model)&#123; User user = new User(); user.setAge(21); user.setName("Jack Chen"); user.setFriend(new User("李小龙", 30)); model.addAttribute("user", user); return "show2";&#125; 语法说明： Thymeleaf通过${}来获取model中的变量，注意这不是el表达式，而是ognl表达式，但是语法非常像。 示例： 我们在页面获取user数据： &lt;h1&gt; 欢迎您：&lt;span th:text="$&#123;user.name&#125;"&gt;请登录&lt;/span&gt;&lt;/h1&gt; 效果： 感觉跟el表达式几乎是一样的。不过区别在于，我们的表达式写在一个名为：th:text的标签属性中，这个叫做指令 动静结合 指令： Thymeleaf崇尚自然模板，意思就是模板是纯正的html代码，脱离模板引擎，在纯静态环境也可以直接运行。现在如果我们直接在html中编写 ${}这样的表达式，显然在静态环境下就会出错，这不符合Thymeleaf的理念。 Thymeleaf中所有的表达式都需要写在指令中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以th:开头。因为表达式${user.name}是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了！ 现在，我们不经过SpringMVC，而是直接用浏览器打开页面看看： 静态页面中，th指令不被识别，但是浏览器也不会报错，把它当做一个普通属性处理。这样span的默认值请登录就会展现在页面 如果是在Thymeleaf环境下，th指令就会被识别和解析，而th:text的含义就是替换所在标签中的文本内容，于是user.name的值就替代了 span中默认的请登录 指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。 向下兼容 但是要注意，如果浏览器不支持Html5怎么办？ 如果不支持这种th:的命名空间写法，那么可以把th:text换成 data-th-text，Thymeleaf也可以兼容。 escape 另外，th:text指令出于安全考虑，会把表达式读取到的值进行处理，防止html的注入。 例如，&lt;p&gt;你好&lt;/p&gt;将会被格式化输出为$lt;p$gt;你好$lt;/p$lt;。 如果想要不进行格式化输出，而是要输出原始内容，则使用th:utext来代替. ognl表达式的语法糖刚才获取变量值，我们使用的是经典的对象.属性名方式。但有些情况下，我们的属性名可能本身也是变量，怎么办？ ognl提供了类似js的语法方式： 例如：${user.name} 可以写作${user[&#39;name&#39;]} 4.2.自定义变量 场景 看下面的案例： &lt;h2&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;user.name&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Age: &lt;span th:text="$&#123;user.age&#125;"&gt;21&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;friend: &lt;span th:text="$&#123;user.friend.name&#125;"&gt;Rose&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 我们获取用户的所有信息，分别展示。 当数据量比较多的时候，频繁的写user.就会非常麻烦。 因此，Thymeleaf提供了自定义变量来解决： 示例： &lt;h2 th:object="$&#123;user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;name&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Age: &lt;span th:text="*&#123;age&#125;"&gt;21&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;friend: &lt;span th:text="*&#123;friend.name&#125;"&gt;Rose&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 首先在 h2上 用 th:object=&quot;${user}&quot;获取user的值，并且保存 然后，在h2内部的任意元素上，可以通过 *{属性名}的方式，来获取user中的属性，这样就省去了大量的user.前缀了 4.3.方法 ognl表达式中的方法调用 ognl表达式本身就支持方法调用，例如： &lt;h2 th:object="$&#123;user&#125;"&gt; &lt;p&gt;FirstName: &lt;span th:text="*&#123;name.split(' ')[0]&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;LastName: &lt;span th:text="*&#123;name.split(' ')[1]&#125;"&gt;Li&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 这里我们调用了name（是一个字符串）的split方法。 Thymeleaf内置对象 Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用#对象名来引用。 一些环境相关对象 对象 作用 #ctx 获取Thymeleaf自己的Context对象 #requset 如果是web程序，可以获取HttpServletRequest对象 #response 如果是web程序，可以获取HttpServletReponse对象 #session 如果是web程序，可以获取HttpSession对象 #servletContext 如果是web程序，可以获取HttpServletContext对象 Thymeleaf提供的全局对象： 对象 作用 #dates 处理java.util.date的工具对象 #calendars 处理java.util.calendar的工具对象 #numbers 用来对数字格式化的方法 #strings 用来处理字符串的方法 #bools 用来判断布尔值的方法 #arrays 用来处理数组的方法 #lists 用来处理List集合的方法 #sets 用来处理set集合的方法 #maps 用来处理map集合的方法 举例 我们在环境变量中添加日期类型对象 @GetMapping("show3")public String show3(Model model)&#123; model.addAttribute("today", new Date()); return "show3";&#125; 在页面中处理 &lt;p&gt; 今天是: &lt;span th:text="$&#123;#dates.format(today,'yyyy-MM-dd')&#125;"&gt;2018-04-25&lt;/span&gt;&lt;/p&gt; 效果： 4.4 字面值有的时候，我们需要在指令中填写基本类型如：字符串、数值、布尔等，并不希望被Thymeleaf解析为变量，这个时候称为字面值。 字符串字面值 使用一对&#39;引用的内容就是字符串字面值了： &lt;p&gt; 你正在观看 &lt;span th:text="'thymeleaf'"&gt;template&lt;/span&gt; 的字符串常量值.&lt;/p&gt; th:text中的thymeleaf并不会被认为是变量，而是一个字符串 数字字面值 数字不需要任何特殊语法， 写的什么就是什么，而且可以直接进行算术运算 &lt;p&gt;今年是 &lt;span th:text="2018"&gt;1900&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;两年后将会是 &lt;span th:text="2018 + 2"&gt;1902&lt;/span&gt;.&lt;/p&gt; 布尔字面值 布尔类型的字面值是true或false： &lt;div th:if="true"&gt; 你填的是true&lt;/div&gt; 这里引用了一个th:if指令，跟vue中的v-if类似 4.5 拼接我们经常会用到普通字符串与表达式拼接的情况： &lt;span th:text="'欢迎您:' + $&#123;user.name&#125; + '!'"&gt;&lt;/span&gt; 字符串字面值需要用&#39;&#39;，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对|即可： &lt;span th:text="|欢迎您:$&#123;user.name&#125;|"&gt;&lt;/span&gt; 与上面是完全等效的，这样就省去了字符串字面值的书写。 4.6 运算需要注意：${}内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在${}外进行。 算术运算 支持的算术运算符：+ - * / % &lt;span th:text="$&#123;user.age&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;user.age&#125;%2 == 0"&gt;&lt;/span&gt; 比较运算 支持的比较运算：&gt;, &lt;, &gt;= and &lt;= ，但是&gt;, &lt;不能直接使用，因为xml会解析为标签，要使用别名。 注意 == and !=不仅可以比较数值，类似于equals的功能。 可以使用的别名：gt (&gt;), lt (&lt;), ge (&gt;=), le (&lt;=), not (!). Also eq (==), neq/ne (!=). 条件运算 三元运算 &lt;span th:text="$&#123;user.sex&#125; ? '男':'女'"&gt;&lt;/span&gt; 三元运算符的三个部分：conditon ? then : else ​ condition：条件 ​ then：条件成立的结果 ​ else：不成立的结果 其中的每一个部分都可以是Thymeleaf中的任意表达式。 默认值 有的时候，我们取一个值可能为空，这个时候需要做非空判断，可以使用 表达式 ?: 默认值简写： &lt;span th:text="$&#123;user.name&#125; ?: '二狗'"&gt;&lt;/span&gt; 当前面的表达式值为null时，就会使用后面的默认值。 注意：?:之间没有空格。 4.7 循环循环也是非常频繁使用的需求，我们使用th:each指令来完成： 假如有用户的集合：users在Context中。 &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;2.41&lt;/td&gt;&lt;/tr&gt; ${users} 是要遍历的集合，可以是以下类型： Iterable，实现了Iterable接口的类 Enumeration，枚举 Interator，迭代器 Map，遍历得到的是Map.Entry Array，数组及其它一切符合数组结果的对象 在迭代的同时，我们也可以获取迭代的状态对象： &lt;tr th:each="user,stat : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;2.41&lt;/td&gt;&lt;/tr&gt; stat对象包含以下属性： index，从0开始的角标 count，元素的个数，从1开始 size，总元素个数 current，当前遍历到的元素 even/odd，返回是否为奇偶，boolean值 first/last，返回是否为第一或最后，boolean值 4.8 逻辑判断有了if和else，我们能实现一切功能^_^。 Thymeleaf中使用th:if 或者 th:unless ，两者的意思恰好相反。 &lt;span th:if="$&#123;user.age&#125; &lt; 24"&gt;小鲜肉&lt;/span&gt; 如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。 以下情况被认定为true： 表达式值为true 表达式值为非0数值 表达式值为非0字符 表达式值为字符串，但不是&quot;false&quot;,&quot;no&quot;,&quot;off&quot; 表达式不是布尔、字符串、数字、字符中的任何一种 其它情况包括null都被认定为false 4.9 分支控制switch这里要使用两个指令：th:switch 和 th:case &lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;用户是管理员&lt;/p&gt; &lt;p th:case="'manager'"&gt;用户是经理&lt;/p&gt; &lt;p th:case="*"&gt;用户是别的玩意&lt;/p&gt;&lt;/div&gt; 需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。 另外th:case=&quot;*&quot;表示默认，放最后。 页面： 4.10.JS模板模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来： &lt;script th:inline="javascript"&gt; const user = /*[[$&#123;user&#125;]]*/ &#123;&#125;; const age = /*[[$&#123;user.age&#125;]]*/ 20; console.log(user); console.log(age)&lt;/script&gt; 在script标签中通过th:inline=&quot;javascript&quot;来声明这是要特殊处理的js脚本 语法结构： const user = /*[[Thymeleaf表达式]]*/ "静态环境下的默认值"; 因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。 看看页面的源码： 我们的User对象被直接处理为json格式了，非常方便。 控制台：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker上安装Elasticsearch]]></title>
    <url>%2F2019%2F09%2F24%2FDocker%E4%B8%8A%E5%AE%89%E8%A3%85Elasticsearch%2F</url>
    <content type="text"><![CDATA[1.Elasticsearch安装1.1 拉取镜像 docker pull ElasticSearch 1.2 创建并启动容器 清理内存： 释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）: syncecho 3 &gt; /proc/sys/vm/drop_caches 启动容器： # docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name &lt;容器名称&gt; &lt;镜像ID&gt; ElasticSearch是用Java写的，它默认会占用2GB的堆内存空间，-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;限制内存为256MB docker ps查看 docker logs![1569054370710](D:\blog\source\_posts\Docker上安装Elasticsearch\1569054370710.png) &lt;容器ID&gt;查看日志信息，可能会报如下错误（再次docker ps会发现elasticsearch没有启动） 解决方法： 切换到root用户修改配置sysctl.conf # vi /etc/sysctl.conf 添加配置： # vm.max_map_count=655360 并执行命令： # sysctl -p docker start &lt;容器ID&gt;重新启动elasticsearch，即可启动成功。 1.3 检查 浏览器URL地址输入&lt;ip地址&gt;：9200，会出现如下JSON格式的数据。 1.4 Java 使用 9300 端口连接ES 会出现如下错误 NoNodeAvailableException[None of the configured nodes are available:[&#123;#transport#‐1&#125;&#123;exvgJLR‐RlCNMJy‐hzKtnA&#125;&#123;xxxx&#125;&#123;xxxx&#125;]]at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodes AreAvailableat org.elasticsearch.client.transport.TransportClientNodesService.executeat org.elasticsearch.client.transport.TransportProxyClient.execute 解决方法： 拷贝配置文件到宿主机（docker中的elasticsearch容器必须是启动的）： # docker cp &lt;容器ID&gt;:/usr/share/elasticsearch/config/elasticsearch.yml /usr/local/elasticsearch/elasticsearch.yml 停止elasticsearch容器并删除它 # docker stop &lt;容器ID&gt; 查看停止的容器： # docker ps -a 删除容器 # docker rm -f &lt;容器ID&gt; 重新创建容器，此时需要挂载文件 # docker run -di -e ES_JAVA_OPTS="-Xms256m -Xmx256m" --name=&lt;容器名称&gt; -p 9200:9200 -p 9300:9300 -v /usr/local/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.5.0 在/usr/local/elasticsearch/elasticsearch.yml文件中添加transport.host: 0.0.0.0，配置如下： cluster.name: "docker-cluster"network.host: 0.0.0.0transport.host: 0.0.0.0# minimum_master_nodes need to be explicitly set when bound on a public IP# set to 1 to allow single node clusters# Details: https://github.com/elastic/elasticsearch/pull/17288discovery.zen.minimum_master_nodes: 1#允许跨域http.cors.enabled: truehttp.cors.allow-origin: "*" 2. 安装IK中文分词器 从github下载ik，下载地址：(注意：IK分词器的版本和elasticsearch的版本要一致) https://github.com/medcl/elasticsearch-analysis-ik/releases 下载解压复制到宿主机 /usr/local/elasticsearch目录下 进入/usr/local/elasticsearch`目录 # cd /usr/local/elasticsearch 复制到elasticsearch容器中 # docker cp elasticsearch-analysis-ik-6.5.0 &lt;容器ID&gt;:/usr/share/elasticsearch/plugins 重启elasticsearch容器 # docker restart &lt;容器ID&gt; 检查是否安装成功： PUT http://&lt;你的ip&gt;:9200/_analyze&#123; "analyzer":"ik_smart", "text":"中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首"&#125; 结果如下： &#123; "tokens": [ &#123; "token": "中国", "start_offset": 0, "end_offset": 2, "type": "CN_WORD", "position": 0 &#125;, &#123; "token": "驻", "start_offset": 2, "end_offset": 3, "type": "CN_CHAR", "position": 1 &#125;, &#123; "token": "洛杉矶", "start_offset": 3, "end_offset": 6, "type": "CN_WORD", "position": 2 &#125;, &#123; "token": "领事馆", "start_offset": 6, "end_offset": 9, "type": "CN_WORD", "position": 3 &#125;, &#123; "token": "遭", "start_offset": 9, "end_offset": 10, "type": "CN_CHAR", "position": 4 &#125;, &#123; "token": "亚裔", "start_offset": 10, "end_offset": 12, "type": "CN_WORD", "position": 5 &#125;, &#123; "token": "男子", "start_offset": 12, "end_offset": 14, "type": "CN_WORD", "position": 6 &#125;, &#123; "token": "枪击", "start_offset": 14, "end_offset": 16, "type": "CN_WORD", "position": 7 &#125;, &#123; "token": "嫌犯", "start_offset": 17, "end_offset": 19, "type": "CN_WORD", "position": 8 &#125;, &#123; "token": "已", "start_offset": 19, "end_offset": 20, "type": "CN_CHAR", "position": 9 &#125;, &#123; "token": "自首", "start_offset": 20, "end_offset": 22, "type": "CN_WORD", "position": 10 &#125; ]&#125; 3.出现的问题及解决方法 cluster block exception： &#123; "error": &#123; "root_cause": [ &#123; "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125; ], "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125;, "status": 403&#125; 解决方法： PUT http://&lt;你的IP&gt;:9200/_all/_settings&#123; "index.blocks.read_only_allow_delete": null&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一异常处理]]></title>
    <url>%2F2019%2F09%2F24%2Fspring%20boot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[统一的响应结果类型​ 在实际的spring boot项目开发过程中，我们后端要返回统一的Json数据格式给前端，便于前端对数据的处理。通常情况下，后端返回给前端的数据类型都是包含操作代码、返回信息、操作是否成功字段，例如： /** * 统一的响应结果类 *///lombok注解@Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息&#125; 如果有其他字段需求，如时间戳、返回的类型可以对上面的统一响应结果类进行继承。例如： @Data@NoArgsConstructor@AllArgsConstructor@Getterpublic class ObjectResponseResult extends ResponseResult &#123; private Date date; private Object data; &#125; 自定义错误代码： 每个业务操作的异常使用异常代码去标识。 错误代码接口，里面定义三个基本的抽象方法。 public interface ResultCode &#123; //操作是否成功,true为成功，false操作失败 boolean success(); //操作代码 int code(); //提示信息 String message();&#125; 公共的错误代码枚举类，实现了错误代码接口，里面的三个字段和ResponseResult一致： @ToStringpublic enum CommonCode implements ResultCode &#123; SUCCESS(true,10000,"操作成功！"), FAIL(false,11111,"操作失败！"), SERVER_ERROR(false,11011,"抱歉，系统繁忙，请稍后重试！"), REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"), ARGS_ERROR(false,10003,"参数错误！"); ; //操作是否成功 boolean success; //操作代码 int code; //提示信息 String message; CommonCode(boolean success, int code, String message) &#123; this.success=success; this.code=code; this.message=message; &#125; @Override public boolean success() &#123; return success; &#125; @Override public int code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 为了方便拿到指自定义的错误代码枚举类中的信息，可以在ResponseResult类中添加构造方法,并且初始化两种响应结果成功和失败： @Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息 public ResponseResult(ResultCode resultCode)&#123; this.success=resultCode.success(); this.code=resultCode.code(); this.message=resultCode.message(); &#125; public static ResponseResult SUCCESS()&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; public static ResponseResult FAIL()&#123; return new ResponseResult(CommonCode.FAIL); &#125;&#125; 统一的异常处理系统对异常的处理使用统一的异常处理流程： 自定义异常类型。 自定义错误代码及错误信息。 对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较 齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。 对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 RuntimeException类型（运行时异常）。 可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随 请求响应给客户端。 异常的类型： 可预知的异常：程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，例如判断用户为空时，抛出自定义异常，异常的错误信息可以写“用户为空” 不可预知的异常：由SpringMVC统一捕获Exception类型的异常。 异常抛出及处理流程： 在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 统一由异常捕获类捕获异常，并进行处理 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误 信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为11011错误代码并响应给用户 将错误代码及错误信息以Json格式响应给用户。 可预知异常处理:自定义异常类： ** * 自定义异常类（可预知的异常） */public class MyException extends RuntimeException &#123; ResultCode resultCode;//错误代码 public MyException(ResultCode resultCode)&#123; this.resultCode=resultCode; &#125; public ResultCode getResultCode()&#123; return resultCode; &#125;&#125; 抛出异常类： 每次抛出自定义异常都要写：throw new MyException(错误代码);为了简便书写，可以将抛出的自定义异常进行封装 public class ExceptionCast &#123; //将抛出的自定义异常进行封装 public static void Cast(ResultCode resultCode)&#123; throw new MyException(resultCode); &#125;&#125; 异常捕获类： 使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常 /** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125;&#125; 注：因为返回的结果为Json格式的数据，需要上@ResponseBody注解，如果不写@ResponseBody注解可以将@ControllerAdvice注解改为@RestControllerAdvice，@RestController=@Controller+@ResponseBody 异常处理测试： 在controller、service、dao中都可以抛出异常 @RestController@RequestMapping("/index")public class indexController &#123; @GetMapping("/&#123;id&#125;") public ResponseResult findById(@PathVariable String id)&#123; if(id.equals("123")&#123; ExceptionCast.Cast(CommonCode.FAIL); &#125; return ResponseResult.SUCCESS(); &#125;&#125; 使用postman测试，结果： Get:http://localhost:8888/index/1 &#123; "success": true, "code": 10000, "message": "操作成功！"&#125; Get:http://localhost:8888/index/123 &#123; "success": false, "code": 10003, "message": "参数错误！"&#125; 不可预知异常处理：​ 当以put方式请求http://localhost:8888/index/1 时，SpringMVC会如下异常： org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported 具体的响应信息： &#123; "timestamp": "2019-08-12T13:44:21.910+0000", "status": 405, "error": "Method Not Allowed", "message": "Request method 'PUT' not supported", "trace": "xxxx..........", "path": "/index/1"&#125; 此时的响应信息前端是无法进行解析的。 在异常捕获类中添加对Exception类异常的捕获： //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); return new ResponseResult(CommonCode.SERVER_ERROR); &#125; 再进行测试，响应的结果如下： &#123; "success": false, "code": 11011, "message": "抱歉，系统繁忙，请稍后重试！"&#125; 虽然对SpringMVC报的异常进行捕获了，但是响应的结果都是“抱歉，系统繁忙，请稍后重试！”。 当我们以非Get方式请求http://localhost:8888/index/1 时，我们希望响应的结果是“请求方式错误！” 针对上面的问题其解决的方法是： 在map中配置Exception类和ResultCode（上述的错误代码类） 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型和错误代码，如果存在错误代码则返回此错误代码，否则返回11011（“抱歉，系统繁忙，请稍后重试！”）错误。 具体实现如下： 在通用错误代码类CommonCode中添加请求方式错误异常。 REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"); 在异常捕获类中定义map类型的异常，key为异常类型，value为错误代码，将SpingMVC抛出的异常类添加到map中，在捕获Exception类异常时取出map中的错误代码ResultCode，最后返回响应结果。捕获异常类完整代码： package com.myblog.exception;import com.google.common.collect.ImmutableMap;import com.myblog.model.response.CommonCode;import com.myblog.model.response.ResponseResult;import com.myblog.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.HashMap;import java.util.Map;/** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125; static Map&lt;Class&lt;?extends Throwable&gt;,ResultCode&gt; exceptionMap=new HashMap&lt;&gt;(); //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); ResultCode resultCode=exceptionMap.get(exception.getClass()); if(resultCode!=null)&#123; return new ResponseResult(resultCode); &#125; return new ResponseResult(CommonCode.SERVER_ERROR); &#125; //在这里加入一些基础的异常类型判断 static &#123; //springmvc报异常：org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported，将HttpRequestMethodNotSupportedException添加到exceptionMap中。 exceptionMap.put(HttpRequestMethodNotSupportedException.class,CommonCode.REQUEST_METHOD_ERROR); &#125;&#125; 测试： 用PUT方式（或者其他非Get方式）请求：http://localhost:8888/index/1 响应结果： &#123; &quot;success&quot;: false, &quot;code&quot;: 10002, &quot;message&quot;: &quot;请求方式错误！&quot;&#125; ​]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
