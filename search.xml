<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis查询树形结构数据]]></title>
    <url>%2Fposts%2Fe8e2ee81%2F</url>
    <content type="text"><![CDATA[数据表的设计创建数据表对于树形结构的数据库设计通常是基于继承关系设计的，也就是通过父ID关联来实现的。 一张树形结构的数据表基本的三个字段：id（自己）、name（名称）和parentid（父类编号） CREATE TABLE `tree` ( `id` int(20) NOT NULL COMMENT &apos;id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;名称&apos;, `parentid` int(20) NOT NULL COMMENT &apos;父id&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据INSERT INTO `tree` VALUES (&apos;100&apos;, &apos;一级1&apos;, &apos;0&apos;);INSERT INTO `tree` VALUES (&apos;101&apos;, &apos;一级2&apos;, &apos;0&apos;);INSERT INTO `tree` VALUES (&apos;201&apos;, &apos;二级1-1&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;202&apos;, &apos;二级1-2&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;203&apos;, &apos;二级1-3&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;211&apos;, &apos;二级2-1&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;212&apos;, &apos;二级2-2&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;213&apos;, &apos;二级2-3&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;301&apos;, &apos;三级1-1-1&apos;, &apos;201&apos;);INSERT INTO `tree` VALUES (&apos;302&apos;, &apos;三级1-1-2&apos;, &apos;201&apos;);INSERT INTO `tree` VALUES (&apos;311&apos;, &apos;三级1-2-1&apos;, &apos;202&apos;);INSERT INTO `tree` VALUES (&apos;321&apos;, &apos;三级2-1-1&apos;, &apos;211&apos;);INSERT INTO `tree` VALUES (&apos;322&apos;, &apos;三级2-1-2&apos;, &apos;211&apos;);INSERT INTO `tree` VALUES (&apos;331&apos;, &apos;三级2-2-1&apos;, &apos;212&apos;); 实体类@Data@NoArgsConstructor@ToStringpublic class Tree implements Serializable &#123; private Integer id;//id private String name;//名称 private Integer parentid;//父id private List&lt;Tree&gt; children=new ArrayList&lt;&gt;();//孩子 private static final long serialVersionUID = 1L;&#125; 实现方式无论是通过Mybatis的递归查询还是通过代码的递归查询方式其思路都是一致的。 先查询出所有一级节点 再跟进一级节点递归查询出其所有子节点 基于MyBatis的递归查询基于注解 持久层接口： @Mapperpublic interface TreeMapper &#123; @Select("select * from tree where parentid=#&#123;parentId&#125;") //根据父id查询出所有孩子 @Results(&#123; @Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="parentid",column="parentid"), @Result(property="children",column="id",javaType=java.util.List.class, many=@Many(select="cn.ghjcloud.tree.dao.TreeMapper.selectChildrenByPId")) //column为父节点Id &#125;) List&lt;Tree&gt; selectChildrenByPId(Integer parentId); @Select("select * from tree where parentid=0") //查询出所有一级目录 @Results(&#123; @Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="parentid",column="parentid"), @Result(property="children",column="id",javaType=java.util.List.class, many=@Many(select="cn.ghjcloud.tree.dao.TreeMapper.selectChildrenByPId")) &#125;) List&lt;Tree&gt; selectTreeList();&#125; 基于XML TreeMapper.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ghjcloud.tree.dao.TreeMapper"&gt; &lt;resultMap id="BaseResultMap" type="cn.ghjcloud.tree.model.Tree"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="parentid" jdbcType="INTEGER" property="parentid" /&gt; &lt;collection property="children" column="id" javaType="java.util.List" ofType="cn.ghjcloud.tree.model.Tree" select="selectChildrenByPId"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectChildrenByPId" resultMap="BaseResultMap"&gt; select * from tree where parentid=#&#123;parentId&#125; &lt;/select&gt; &lt;select id="selectTreeList" resultMap="BaseResultMap"&gt; select * from tree where parentid=0 &lt;/select&gt;&lt;/mapper&gt; 接口： @Mapperpublic interface TreeMapper &#123; List&lt;Tree&gt; selectChildrenByPId(Integer parentId); List&lt;Tree&gt; selectTreeList();&#125; 注解对应的XML的元素 注解 xml @Results resultMap @Result Result @Many collection column:实体类中对应的属性 property：mysql表中的字段 基于代码的递归查询根据某个父节点递归获取子节点 /** * 根据某个父节点递归获取子节点 * @param parentTree 父节点 * @param list 全部节点 * @return */public Tree getChildrenByPId(Tree parentTree,List&lt;Tree&gt; list)&#123; list.forEach((tree)-&gt;&#123; if(tree.getParentid().equals(parentTree.getId()))&#123; tree=getChildrenByPId(tree,list); parentTree.getChildren().add(tree); &#125; &#125;); return parentTree;&#125; 先获取所有一级节点，再调用上面的getChildrenByPId( )方法递归查询出所有子节点 /** * 递归获取树形结构的数据 * @param list 全部节点 * @return */ private List&lt;Tree&gt; getTreeList(List&lt;Tree&gt; list)&#123; List&lt;Tree&gt; treeList=new ArrayList&lt;&gt;(); list.forEach((tree -&gt; &#123; //获取所有一级节点 if(tree.getParentid()==0)&#123; treeList.add(tree); &#125; &#125;)); // 递归获取子节点 treeList.forEach((parentTree)-&gt;&#123; parentTree=this.getChildrenByPId(parentTree,list); &#125;); return treeList; &#125; 测试基于MyBatis的递归查询service层@Servicepublic class TreeService &#123; @Autowired private TreeMapper treeMapper; public List&lt;Tree&gt; selectTreeList()&#123; List&lt;Tree&gt; trees=treeMapper.selectTreeList(); return trees; &#125;&#125; Controller层@RestController@RequestMapping("/tree")public class TreeController &#123; @Autowired private TreeService treeService; @GetMapping("/list") public ResponseEntity&lt;List&lt;Tree&gt;&gt; selectTreeList()&#123; return ResponseEntity.ok(treeService.selectTreeList()); &#125;&#125; 基于代码的递归查询Mapper接口@Repositorypublic interface TreeMapper extends Mapper&lt;Tree&gt; &#123;&#125; Service层@Servicepublic class TreeService &#123; @Autowired private TreeMapper treeMapper; public List&lt;Tree&gt; findTreeList()&#123; //获取所有节点 List&lt;Tree&gt; list=treeMapper.selectAll(); List&lt;Tree&gt; treeList=this.getTreeList(list); return treeList; &#125; /** * 递归获取树形结构的数据 * @param list 全部节点 * @return */ private List&lt;Tree&gt; getTreeList(List&lt;Tree&gt; list)&#123; List&lt;Tree&gt; treeList=new ArrayList&lt;&gt;(); list.forEach((tree -&gt; &#123; //获取所有一级节点 if(tree.getParentid()==0)&#123; treeList.add(tree); &#125; &#125;)); // 递归获取子节点 treeList.forEach((parentTree)-&gt;&#123; parentTree=this.getChildrenByPId(parentTree,list); &#125;); return treeList; &#125; /** * 根据某个父节点递归获取子节点 * @param parentTree 父节点 * @param list 全部节点 * @return */ public Tree getChildrenByPId(Tree parentTree,List&lt;Tree&gt; list)&#123; list.forEach((tree)-&gt;&#123; if(tree.getParentid().equals(parentTree.getId()))&#123; tree=getChildrenByPId(tree,list); parentTree.getChildren().add(tree); &#125; &#125;); return parentTree; &#125; &#125; Controller层@RestController@RequestMapping("/tree")public class TreeController &#123; @Autowired private TreeService treeService; @GetMapping("/list") public ResponseEntity&lt;List&lt;Tree&gt;&gt; selectTreeList()&#123; return ResponseEntity.ok(treeService.findTreeList()); &#125;&#125; 调试 源码地址：GitHub]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Mybatis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式唯一ID生成策略]]></title>
    <url>%2Fposts%2Fa1e7d1d4%2F</url>
    <content type="text"><![CDATA[为什么要使用分布式ID生成器？互联网应用中，某个表可能要占用很大的物理存储空间，为了解决该问题，使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用ID自增策略，则可能产生重复的ID，此时应该使用分布式ID生成策略来生成ID。 分布式ID的特点 全局唯一，在整个系统中不同模块之间表的主键是唯一的 有序递增性。 常用的分布式ID生成策略数据库主键自增策略优点： 能够保证主键唯一性 能够保证主键递增 此方法是数据库原有的功能，使用简单 数字化的，查询效率高 缺点： 自增的步长是固定的，缺乏安全性。如果订单表的主键是这种生成策略，恶意用户很容易窥见订单号的规则，这样就很容易知道你的订单在某段时间内的数量。 存在单点问题，如果数据库挂了，就没法生成 ID了; 数据库的压力大，高并发扛不住 UUIDUUID是指在一台机器在同一时间中生成的数字在所有机器中都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字UUID由以下几部分的组合：（1）当前日期和时间。（2）时钟序列。（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，以连字号分为五段形式的36个字符，示例：550e8400-e29b-41d4-a716-446655440000在JAVA的类库中已经提供了UUID的API UUID.randomUUID() 优点： 本地生成，性能好，没有高可用风险. 缺点： 不是有序的，无法保证是单调递增 长度过长，往往使用字符串表示，查询效率低 储存空间大 Snowflake（雪花算法）snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。 snowflake算法所生成的ID结构 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点： 简单高效，生成速度快，每秒能够产生26万ID左右。 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点： 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 snowflake Java实现： public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** * @param workerId * 工作机器ID * @param datacenterId * 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** * 获取下一个ID * * @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* * GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式ID</tag>
        <tag>snowflake雪花算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot+FastDFS实现文件上传]]></title>
    <url>%2Fposts%2Ffa2b9b65%2F</url>
    <content type="text"><![CDATA[将文件上传至fastDFS服务并将图片信息保存到MongoDB fastDFS服务器和MongoDB都是部署到Docker容器中 使用Docker下载并运行fastDFS镜像下载docker的fastDFS镜像：（该方法是直接运行 如果没有镜像源就下载） docker run -d --restart=always --privileged=true --net=host --name=fastdfs -e IP=&lt;输入你的ip 如果是云服务器的话 请输入外网ip&gt; -e WEB_PORT=80 -v $&#123;HOME&#125;/fastdfs:/var/local/fdfs registry.cn-beijing.aliyuncs.com/tianzuo/fastdfs ![](Spring Boot +FastDFS实现文件上传/1568043082454.png) 检查fastDFS容器是否安装 docker ps ![](Spring Boot +FastDFS实现文件上传/1568043269157.png) 以交互式的方式进入fastDFS容器 docker exec -it &lt;容器ID&gt; /bin/bash ![](Spring Boot +FastDFS实现文件上传/1568043461180.png) 追加一个html文件,并将文件上传至fastDFS服务器 echo "hello fastDFS! "&gt;hello.htmlfdfs_test /etc/fdfs/client.conf upload hello.html ![1568043889465](Spring Boot +FastDFS实现文件上传/1568043889465.png) 在浏览器中访问file url ![1568043985871](Spring Boot +FastDFS实现文件上传/1568043985871.png) 成功！！ 项目中添加依赖pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springboot-fastdfs-filesystem&lt;/artifactId&gt; &lt;groupId&gt;com.ghjcloud&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ghjcloud&lt;/groupId&gt; &lt;artifactId&gt;springboot-fastDFS-fileSystem&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/net.oschina.zcx7878/fastdfs-client-java --&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类@SpringBootApplication@ComponentScan(basePackages=&#123;"com.ghjcloud.fastDFS.fileSystem.api","com.ghjcloud.fastDFS.fileSystem"&#125;)@EntityScan(basePackages="com.ghjcloud.fastDFS.fileSystem.model")public class fileSystemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(fileSystemApplication.class); &#125;&#125; 配置文件application.ymlspring: application: name: filesystem data: mongodb: database: filesystemdb uri: mongodb://root:root@你的ip:27017/?gssapiServiceName=mongodb #SpringMVC上传文件配置 servlet: multipart: #默认支持文件上传. enabled: true #支持文件写入磁盘. file-size-threshold: 0 # 上传文件的临时目录 location: # 最大支持文件大小 max-file-size: 4MB # 最大支持请求大小 max-request-size: 30MBserver: port: 8011filesystem: fastdfs: connect_timeout_in_seconds: 5 #http连接超时时间 network_timeout_in_seconds: 30 #tracker和storage网络通信超时时长 charset: UTF-8 #字符编码 tracker_servers: 你的ip:22122 #tracker服务器地址，多个 trackerServer中间以逗号分隔 实体类文件类 package com.ghjcloud.fastDFS.fileSystem.model;import lombok.Data;import lombok.ToString;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import java.util.Map;@Data@ToString@Document(collection = "filesystem")//mongodb数据库中的collection（类似于sql中的表）public class FileSystem &#123; @Id private String fileId; //文件请求路径 private String filePath; //文件大小 private long fileSize; //文件名称 private String fileName; //文件类型 private String fileType; //图片宽度 private int fileWidth; //图片高度 private int fileHeight; //用户id，用于授权 private String userId; //业务key private String businesskey; //业务标签 private String filetag; //文件元信息 private Map metadata;&#125; 请求响应返回类型 package com.ghjcloud.fastDFS.fileSystem.model;import lombok.AllArgsConstructor;import lombok.Data;@Data@AllArgsConstructorpublic class ResponseResult &#123; private String message; private int code; private Object data; &#125; 数据访问层package com.ghjcloud.fastDFS.fileSystem.repository;import com.ghjcloud.fastDFS.fileSystem.model.FileSystem;import org.springframework.data.mongodb.repository.MongoRepository;import org.springframework.stereotype.Repository;@Repositorypublic interface FileSystemRepository extends MongoRepository&lt;FileSystem,String&gt; &#123;&#125; 业务层package com.ghjcloud.fastDFS.fileSystem.service;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.ghjcloud.fastDFS.fileSystem.model.FileSystem;import com.ghjcloud.fastDFS.fileSystem.repository.FileSystemRepository;import org.apache.commons.lang3.StringUtils;import org.csource.common.MyException;import org.csource.fastdfs.*;import org.omg.CORBA.NameValuePair;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.util.HashMap;@Service@Transactionalpublic class FileSystemService &#123; @Value(&quot;$&#123;filesystem.fastdfs.connect_timeout_in_seconds&#125;&quot;) int connect_timeout; @Value(&quot;$&#123;filesystem.fastdfs.network_timeout_in_seconds&#125;&quot;) int network_timeout; @Value(&quot;$&#123;filesystem.fastdfs.charset&#125;&quot;) String charset; @Value(&quot;$&#123;filesystem.fastdfs.tracker_servers&#125;&quot;) String tracker_servers; @Autowired private FileSystemRepository fileSystemRepository; /** * 文件上传并将文件信息存储到MongoDB * @param multipartFile 文件 * @param metadata 文件元信息 */ public String fileUpload(MultipartFile multipartFile,String metadata)&#123; this.initFastDFSConfig(); StorageClient1 storageClient1=this.getStorageClient(); String fileId=null; try &#123; byte[] bytes=multipartFile.getBytes(); String originalFilename=multipartFile.getOriginalFilename();//文件原始名称 String ext=originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)+1);//文件扩展名 fileId=storageClient1.upload_file1(bytes,ext,null); FileSystem fileSystem=new FileSystem(); fileSystem.setFileId(fileId); fileSystem.setFileSize(multipartFile.getSize()); fileSystem.setFilePath(fileId); fileSystem.setFileName(multipartFile.getName()); fileSystem.setFileType(multipartFile.getContentType()); if(StringUtils.isNotBlank(metadata))&#123; HashMap map=JSON.parseObject(metadata, HashMap.class); fileSystem.setMetadata(map); &#125; fileSystemRepository.save(fileSystem); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; return fileId; &#125; //获取storage客户端 public StorageClient1 getStorageClient()&#123; //初始化fastDFS this.initFastDFSConfig(); //定义TrackerClient,用于请求TrackerServer TrackerClient trackerClient=new TrackerClient(); try &#123; //连接tracker服务器 TrackerServer trackerServer=trackerClient.getConnection(); //获取storage服务器 StorageServer storageServer=trackerClient.getStoreStorage(trackerServer); //创建storage客户端 return new StorageClient1(trackerServer,storageServer); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; //初始化fastDFS private void initFastDFSConfig() &#123; try &#123; ClientGlobal.initByTrackers(tracker_servers); ClientGlobal.setG_network_timeout(network_timeout); ClientGlobal.setG_connect_timeout(connect_timeout); ClientGlobal.setG_charset(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125; springboot集成swagger2Swagger2配置类 package com.ghjcloud.fastDFS.fileSystem.api;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Configuration &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.ghjcloud.fastDFS")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("FastDFS分布式文件上传demo") .description("FastDFS分布式文件上传demo")// .termsOfServiceUrl("/") .version("1.0.0") .build(); &#125;&#125; api接口 package com.ghjcloud.fastDFS.fileSystem.api;import com.ghjcloud.fastDFS.fileSystem.model.ResponseResult;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;@Api(value = "文件上传",description = "文件上传接口")public interface FileSystemControllerApi &#123; @ApiOperation("文件上传") ResponseResult uploadFile(MultipartFile multipartFile, String metadata);&#125; controller层package com.ghjcloud.fastDFS.fileSystem.controller;import com.ghjcloud.fastDFS.fileSystem.api.FileSystemControllerApi;import com.ghjcloud.fastDFS.fileSystem.model.ResponseResult;import com.ghjcloud.fastDFS.fileSystem.service.FileSystemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestController@RequestMapping("/file")public class SystemFileController implements FileSystemControllerApi &#123; @Autowired private FileSystemService fileSystemService; @Override @PostMapping("/upload") public ResponseResult uploadFile(@RequestParam("file")MultipartFile multipartFile, @RequestParam(value="metadat",required=false)String metadata)&#123; final String fileId=fileSystemService.fileUpload(multipartFile, metadata); return new ResponseResult("上传成功！",200,fileId); &#125;&#125; 测试1.启动项目访问 http://localhost:8011/swagger-ui.html ![1568045179922](Spring Boot +FastDFS实现文件上传/1568045179922.png) ![1568045228317](Spring Boot +FastDFS实现文件上传/1568045228317.png) 2.选择一张文件上传，并查看响应结果 ![1568045326614](Spring Boot +FastDFS实现文件上传/1568045326614.png) ![1568045798321](Spring Boot +FastDFS实现文件上传/1568045798321.png) 3.在浏览器中访问上传到fastDFS服务器的图片 http://fastDFS服务器IP/group1/M00/00/00/wKhOCl12eceAORP3ACo7X7diV14748.jpg ![1568045746137](Spring Boot +FastDFS实现文件上传/1568045746137.png) 4.检查数据是否存储到mongodb数据库 ![1568045968617](Spring Boot +FastDFS实现文件上传/1568045968617.png) 在表filesystem中多一条记录，并且_id和返回的data数据一致 ![1568046088118](Spring Boot +FastDFS实现文件上传/1568046088118.png)]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Spring Boot</tag>
        <tag>FastDFS</tag>
        <tag>MongoDB</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux上安装Logstash并将mysql中数据同步到elasticsearch索引库]]></title>
    <url>%2Fposts%2F21a8dc83%2F</url>
    <content type="text"><![CDATA[elasticsearch安装具体安装过程请看上一篇博客：elasticsearch安装 注：安装elasticsearch之前确保你的环境安装了JDK8及以上版本，elasticsearch版本和logstash版本要一致，我这里使用的都是6.5.0版本。 ruby安装由于logstash-input-jdbc插件是ruby编写的，所有本地需要ruby的运行环境 安装Gem,Ruby是一种脚本语言，Gem是基于Ruby的一些开发工具包 $ yum install gem 配置国内镜像源 $ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 查看是否修改成功：gem sources -l 更新source cache $ gem sources -u logstash安装 官网下载地址： https://www.elastic.co/cn/downloads/logstash 如果要下载其他版本可以点击past release,我这里下载的是6.5.0的版本 下载完成解压后将其复制到虚拟机的/usr/local/logstash目录下 检查logstash是否安装成功 首先进入 logstash的bin目录下执行： 权限不足： chmod 777 ./logstash $ ./logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos; logstash-input-jdbc插件安装$ chmod 777 /usr/local/logstash/logstash-6.5.0/logstash-6.5.0/vendor/jruby/bin/jruby $ ./logstash-plugin install logstash-input-jdbc 创建mysql数据库SET FOREIGN_KEY_CHECKS=0;-------- Table structure for `item`------DROP TABLE IF EXISTS `item`;CREATE TABLE `item` ( `id` bigint(20) NOT NULL, `title` varchar(255) NOT NULL, `category` varchar(255) NOT NULL, `brand` varchar(255) NOT NULL, `price` double NOT NULL, `img` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-------- Records of item------INSERT INTO `item` VALUES ('1110', '华为 G9 青春版 白色 移动联通电信4G手机 双卡双待', '手机', '华为', '2999', 'http://image.jd.com/13123.jpg');INSERT INTO `item` VALUES ('1111', '三星 Galaxy C5（SM-C5000）4GB+32GB 枫叶金 移动联通电信4G手机 双卡双待', '手机', '三星', '5999', 'http://image.jd.com/13123.jpg'); mysql.conf配置文件 将jdbc的驱动复制到虚拟机上，我的是在： /usr/local/logstash/logstash-6.5.0/mysql-connector-java-8.0.13.jar 在logstash的config目录下创建mysql.conf文件,配置如下： input &#123; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://你的ip：3306/shop_db?serverTimezone=GMT%2B8&quot; $url jdbc_user =&gt; &quot;root&quot; $用户名 jdbc_password =&gt; &quot;root&quot; $密码 jdbc_driver_library =&gt; &quot;/usr/local/logstash/logstash-6.5.0/mysql-connector-java-8.0.13.jar&quot; $jdbc驱动的位置 jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; $是否分页 jdbc_page_size =&gt; &quot;10&quot; $每页显示记录数 statement =&gt; &quot;select * from item&quot; $查询出来的数据要同步到索引 schedule =&gt; &quot;* * * * *&quot; $定时任务，每一分钟同步一次 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.78.10:9200&quot; $es地址，多个地址用逗号隔开 index =&gt; &quot;shop&quot; $索引名 document_id =&gt; &quot;%&#123;id&#125;&quot; $ _id document_type =&gt; &quot;item&quot; $类型 &#125; stdout &#123; codec =&gt; json_lines $以json格式输出 &#125;&#125; 注意：我这里用的是mysql8，url需要加上时区参数，jdbc-driver-class是com.mysql.cj.jdbc.Driver，不是com.mysql.jdbc.Driver 实现数据同步在bin目录下执行： $ ./logstash -f ../config/mysql.conf ../是返回上一级目录]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker上安装Elasticsearch]]></title>
    <url>%2Fposts%2Fd7ba9b14%2F</url>
    <content type="text"><![CDATA[Elasticsearch安装拉取镜像docker pull ElasticSearch 创建并启动容器 清理内存： 释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）: syncecho 3 &gt; /proc/sys/vm/drop_caches 启动容器： # docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name &lt;容器名称&gt; &lt;镜像ID&gt; ElasticSearch是用Java写的，它默认会占用2GB的堆内存空间，-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;限制内存为256MB docker ps查看 docker logs![1569054370710](D:\blog\source\_posts\Docker上安装Elasticsearch\1569054370710.png) &lt;容器ID&gt;查看日志信息，可能会报如下错误（再次docker ps会发现elasticsearch没有启动） 解决方法： 切换到root用户修改配置sysctl.conf # vi /etc/sysctl.conf 添加配置： # vm.max_map_count=655360 并执行命令： # sysctl -p docker start &lt;容器ID&gt;重新启动elasticsearch，即可启动成功。 检查浏览器URL地址输入&lt;ip地址&gt;：9200，会出现如下JSON格式的数据。 Java 使用 9300 端口连接ES 会出现如下错误NoNodeAvailableException[None of the configured nodes are available:[&#123;#transport#‐1&#125;&#123;exvgJLR‐RlCNMJy‐hzKtnA&#125;&#123;xxxx&#125;&#123;xxxx&#125;]]at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodes AreAvailableat org.elasticsearch.client.transport.TransportClientNodesService.executeat org.elasticsearch.client.transport.TransportProxyClient.execute 解决方法： 拷贝配置文件到宿主机（docker中的elasticsearch容器必须是启动的）： # docker cp &lt;容器ID&gt;:/usr/share/elasticsearch/config/elasticsearch.yml /usr/local/elasticsearch/elasticsearch.yml 停止elasticsearch容器并删除它 # docker stop &lt;容器ID&gt; 查看停止的容器： # docker ps -a 删除容器 # docker rm -f &lt;容器ID&gt; 重新创建容器，此时需要挂载文件 # docker run -di -e ES_JAVA_OPTS="-Xms256m -Xmx256m" --name=&lt;容器名称&gt; -p 9200:9200 -p 9300:9300 -v /usr/local/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.5.0 在/usr/local/elasticsearch/elasticsearch.yml文件中添加transport.host: 0.0.0.0，配置如下： cluster.name: "docker-cluster"network.host: 0.0.0.0transport.host: 0.0.0.0# minimum_master_nodes need to be explicitly set when bound on a public IP# set to 1 to allow single node clusters# Details: https://github.com/elastic/elasticsearch/pull/17288discovery.zen.minimum_master_nodes: 1#允许跨域http.cors.enabled: truehttp.cors.allow-origin: "*" 安装IK中文分词器 从github下载ik，下载地址：(注意：IK分词器的版本和elasticsearch的版本要一致) https://github.com/medcl/elasticsearch-analysis-ik/releases 下载解压复制到宿主机 /usr/local/elasticsearch目录下 进入/usr/local/elasticsearch`目录 # cd /usr/local/elasticsearch 复制到elasticsearch容器中 # docker cp elasticsearch-analysis-ik-6.5.0 &lt;容器ID&gt;:/usr/share/elasticsearch/plugins 重启elasticsearch容器 # docker restart &lt;容器ID&gt; 检查是否安装成功： PUT http://&lt;你的ip&gt;:9200/_analyze&#123; "analyzer":"ik_smart", "text":"中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首"&#125; 结果如下： &#123; "tokens": [ &#123; "token": "中国", "start_offset": 0, "end_offset": 2, "type": "CN_WORD", "position": 0 &#125;, &#123; "token": "驻", "start_offset": 2, "end_offset": 3, "type": "CN_CHAR", "position": 1 &#125;, &#123; "token": "洛杉矶", "start_offset": 3, "end_offset": 6, "type": "CN_WORD", "position": 2 &#125;, &#123; "token": "领事馆", "start_offset": 6, "end_offset": 9, "type": "CN_WORD", "position": 3 &#125;, &#123; "token": "遭", "start_offset": 9, "end_offset": 10, "type": "CN_CHAR", "position": 4 &#125;, &#123; "token": "亚裔", "start_offset": 10, "end_offset": 12, "type": "CN_WORD", "position": 5 &#125;, &#123; "token": "男子", "start_offset": 12, "end_offset": 14, "type": "CN_WORD", "position": 6 &#125;, &#123; "token": "枪击", "start_offset": 14, "end_offset": 16, "type": "CN_WORD", "position": 7 &#125;, &#123; "token": "嫌犯", "start_offset": 17, "end_offset": 19, "type": "CN_WORD", "position": 8 &#125;, &#123; "token": "已", "start_offset": 19, "end_offset": 20, "type": "CN_CHAR", "position": 9 &#125;, &#123; "token": "自首", "start_offset": 20, "end_offset": 22, "type": "CN_WORD", "position": 10 &#125; ]&#125; 出现的问题及解决方法 cluster block exception： &#123; "error": &#123; "root_cause": [ &#123; "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125; ], "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125;, "status": 403&#125; 解决方法： PUT http://&lt;你的IP&gt;:9200/_all/_settings&#123; "index.blocks.read_only_allow_delete": null&#125;]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thymeleaf语法入门]]></title>
    <url>%2Fposts%2F754c99f8%2F</url>
    <content type="text"><![CDATA[1.Thymeleaf简介官方网站：https://www.thymeleaf.org/index.html Thymeleaf是用来开发Web和独立环境项目的现代服务器端Java模板引擎。 Thymeleaf的主要目标是为您的开发工作流程带来优雅的自然模板 - HTML。可以在直接浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。 借助Spring Framework的模块，可以根据自己的喜好进行自由选择，可插拔功能组件，Thymeleaf是现代HTML5 JVM Web开发的理想选择 - 尽管它可以做的更多。 Spring官方支持的服务的渲染模板中，并不包含jsp。而是Thymeleaf和Freemarker等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。 2.特点特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 3.环境准备我们来创建一个module，为学习Thymeleaf做准备： 3.1.创建module使用spring 脚手架创建： 勾选web和Thymeleaf的依赖： 项目结构： pom： &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;thymeleaf-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.2.默认配置不需要做任何配置，启动器已经帮我们把Thymeleaf的视图器配置完成： 而且，还配置了模板文件（html）的位置，与jsp类似的前缀+ 视图名 + 后缀风格： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html Thymeleaf默认会开启页面缓存，提高页面并发能力。但会导致我们修改页面不会立即被展现，因此我们关闭缓存： # 关闭Thymeleaf的缓存spring.thymeleaf.cache=false 另外，修改完毕页面，需要使用快捷键：Ctrl + Shift + F9来刷新工程。 3.3.快速开始我们准备一个controller，控制视图跳转： @Controllerpublic class HelloController &#123; @GetMapping("show1") public String show1(Model model)&#123; model.addAttribute("msg", "Hello, Thymeleaf!"); return "hello"; &#125;&#125; 新建一个html模板： &lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text="$&#123;msg&#125;"&gt;大家好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 启动项目，访问页面： 4.语法Thymeleaf的主要作用是把model中的数据渲染到html中，因此其语法主要是如何解析model中的数据。从以下方面来学习： 变量 方法 条件判断 循环 运算 逻辑运算 布尔运算 比较运算 条件运算 其它 4.1.变量变量案例我们先新建一个实体类：User public class User &#123; String name; int age; User friend;// 对象类型属性&#125; 然后在模型中添加数据 @GetMapping("show2")public String show2(Model model)&#123; User user = new User(); user.setAge(21); user.setName("Jack Chen"); user.setFriend(new User("李小龙", 30)); model.addAttribute("user", user); return "show2";&#125; 语法说明： Thymeleaf通过${}来获取model中的变量，注意这不是el表达式，而是ognl表达式，但是语法非常像。 示例： 我们在页面获取user数据： &lt;h1&gt; 欢迎您：&lt;span th:text="$&#123;user.name&#125;"&gt;请登录&lt;/span&gt;&lt;/h1&gt; 效果： 感觉跟el表达式几乎是一样的。不过区别在于，我们的表达式写在一个名为：th:text的标签属性中，这个叫做指令 动静结合 指令： Thymeleaf崇尚自然模板，意思就是模板是纯正的html代码，脱离模板引擎，在纯静态环境也可以直接运行。现在如果我们直接在html中编写 ${}这样的表达式，显然在静态环境下就会出错，这不符合Thymeleaf的理念。 Thymeleaf中所有的表达式都需要写在指令中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以th:开头。因为表达式${user.name}是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了！ 现在，我们不经过SpringMVC，而是直接用浏览器打开页面看看： 静态页面中，th指令不被识别，但是浏览器也不会报错，把它当做一个普通属性处理。这样span的默认值请登录就会展现在页面 如果是在Thymeleaf环境下，th指令就会被识别和解析，而th:text的含义就是替换所在标签中的文本内容，于是user.name的值就替代了 span中默认的请登录 指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。 向下兼容 但是要注意，如果浏览器不支持Html5怎么办？ 如果不支持这种th:的命名空间写法，那么可以把th:text换成 data-th-text，Thymeleaf也可以兼容。 escape 另外，th:text指令出于安全考虑，会把表达式读取到的值进行处理，防止html的注入。 例如，&lt;p&gt;你好&lt;/p&gt;将会被格式化输出为$lt;p$gt;你好$lt;/p$lt;。 如果想要不进行格式化输出，而是要输出原始内容，则使用th:utext来代替. ognl表达式的语法糖刚才获取变量值，我们使用的是经典的对象.属性名方式。但有些情况下，我们的属性名可能本身也是变量，怎么办？ ognl提供了类似js的语法方式： 例如：${user.name} 可以写作${user[&#39;name&#39;]} 4.2.自定义变量 场景 看下面的案例： &lt;h2&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;user.name&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Age: &lt;span th:text="$&#123;user.age&#125;"&gt;21&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;friend: &lt;span th:text="$&#123;user.friend.name&#125;"&gt;Rose&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 我们获取用户的所有信息，分别展示。 当数据量比较多的时候，频繁的写user.就会非常麻烦。 因此，Thymeleaf提供了自定义变量来解决： 示例： &lt;h2 th:object="$&#123;user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;name&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Age: &lt;span th:text="*&#123;age&#125;"&gt;21&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;friend: &lt;span th:text="*&#123;friend.name&#125;"&gt;Rose&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 首先在 h2上 用 th:object=&quot;${user}&quot;获取user的值，并且保存 然后，在h2内部的任意元素上，可以通过 *{属性名}的方式，来获取user中的属性，这样就省去了大量的user.前缀了 4.3.方法 ognl表达式中的方法调用 ognl表达式本身就支持方法调用，例如： &lt;h2 th:object="$&#123;user&#125;"&gt; &lt;p&gt;FirstName: &lt;span th:text="*&#123;name.split(' ')[0]&#125;"&gt;Jack&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;LastName: &lt;span th:text="*&#123;name.split(' ')[1]&#125;"&gt;Li&lt;/span&gt;.&lt;/p&gt;&lt;/h2&gt; 这里我们调用了name（是一个字符串）的split方法。 Thymeleaf内置对象 Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用#对象名来引用。 一些环境相关对象 对象 作用 #ctx 获取Thymeleaf自己的Context对象 #requset 如果是web程序，可以获取HttpServletRequest对象 #response 如果是web程序，可以获取HttpServletReponse对象 #session 如果是web程序，可以获取HttpSession对象 #servletContext 如果是web程序，可以获取HttpServletContext对象 Thymeleaf提供的全局对象： 对象 作用 #dates 处理java.util.date的工具对象 #calendars 处理java.util.calendar的工具对象 #numbers 用来对数字格式化的方法 #strings 用来处理字符串的方法 #bools 用来判断布尔值的方法 #arrays 用来处理数组的方法 #lists 用来处理List集合的方法 #sets 用来处理set集合的方法 #maps 用来处理map集合的方法 举例 我们在环境变量中添加日期类型对象 @GetMapping("show3")public String show3(Model model)&#123; model.addAttribute("today", new Date()); return "show3";&#125; 在页面中处理 &lt;p&gt; 今天是: &lt;span th:text="$&#123;#dates.format(today,'yyyy-MM-dd')&#125;"&gt;2018-04-25&lt;/span&gt;&lt;/p&gt; 效果： 4.4 字面值有的时候，我们需要在指令中填写基本类型如：字符串、数值、布尔等，并不希望被Thymeleaf解析为变量，这个时候称为字面值。 字符串字面值 使用一对&#39;引用的内容就是字符串字面值了： &lt;p&gt; 你正在观看 &lt;span th:text="'thymeleaf'"&gt;template&lt;/span&gt; 的字符串常量值.&lt;/p&gt; th:text中的thymeleaf并不会被认为是变量，而是一个字符串 数字字面值 数字不需要任何特殊语法， 写的什么就是什么，而且可以直接进行算术运算 &lt;p&gt;今年是 &lt;span th:text="2018"&gt;1900&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;两年后将会是 &lt;span th:text="2018 + 2"&gt;1902&lt;/span&gt;.&lt;/p&gt; 布尔字面值 布尔类型的字面值是true或false： &lt;div th:if="true"&gt; 你填的是true&lt;/div&gt; 这里引用了一个th:if指令，跟vue中的v-if类似 4.5 拼接我们经常会用到普通字符串与表达式拼接的情况： &lt;span th:text="'欢迎您:' + $&#123;user.name&#125; + '!'"&gt;&lt;/span&gt; 字符串字面值需要用&#39;&#39;，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对|即可： &lt;span th:text="|欢迎您:$&#123;user.name&#125;|"&gt;&lt;/span&gt; 与上面是完全等效的，这样就省去了字符串字面值的书写。 4.6 运算需要注意：${}内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在${}外进行。 算术运算 支持的算术运算符：+ - * / % &lt;span th:text="$&#123;user.age&#125;"&gt;&lt;/span&gt;&lt;span th:text="$&#123;user.age&#125;%2 == 0"&gt;&lt;/span&gt; 比较运算 支持的比较运算：&gt;, &lt;, &gt;= and &lt;= ，但是&gt;, &lt;不能直接使用，因为xml会解析为标签，要使用别名。 注意 == and !=不仅可以比较数值，类似于equals的功能。 可以使用的别名：gt (&gt;), lt (&lt;), ge (&gt;=), le (&lt;=), not (!). Also eq (==), neq/ne (!=). 条件运算 三元运算 &lt;span th:text="$&#123;user.sex&#125; ? '男':'女'"&gt;&lt;/span&gt; 三元运算符的三个部分：conditon ? then : else ​ condition：条件 ​ then：条件成立的结果 ​ else：不成立的结果 其中的每一个部分都可以是Thymeleaf中的任意表达式。 默认值 有的时候，我们取一个值可能为空，这个时候需要做非空判断，可以使用 表达式 ?: 默认值简写： &lt;span th:text="$&#123;user.name&#125; ?: '二狗'"&gt;&lt;/span&gt; 当前面的表达式值为null时，就会使用后面的默认值。 注意：?:之间没有空格。 4.7 循环循环也是非常频繁使用的需求，我们使用th:each指令来完成： 假如有用户的集合：users在Context中。 &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;2.41&lt;/td&gt;&lt;/tr&gt; ${users} 是要遍历的集合，可以是以下类型： Iterable，实现了Iterable接口的类 Enumeration，枚举 Interator，迭代器 Map，遍历得到的是Map.Entry Array，数组及其它一切符合数组结果的对象 在迭代的同时，我们也可以获取迭代的状态对象： &lt;tr th:each="user,stat : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;2.41&lt;/td&gt;&lt;/tr&gt; stat对象包含以下属性： index，从0开始的角标 count，元素的个数，从1开始 size，总元素个数 current，当前遍历到的元素 even/odd，返回是否为奇偶，boolean值 first/last，返回是否为第一或最后，boolean值 4.8 逻辑判断有了if和else，我们能实现一切功能^_^。 Thymeleaf中使用th:if 或者 th:unless ，两者的意思恰好相反。 &lt;span th:if="$&#123;user.age&#125; &lt; 24"&gt;小鲜肉&lt;/span&gt; 如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。 以下情况被认定为true： 表达式值为true 表达式值为非0数值 表达式值为非0字符 表达式值为字符串，但不是&quot;false&quot;,&quot;no&quot;,&quot;off&quot; 表达式不是布尔、字符串、数字、字符中的任何一种 其它情况包括null都被认定为false 4.9 分支控制switch这里要使用两个指令：th:switch 和 th:case &lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;用户是管理员&lt;/p&gt; &lt;p th:case="'manager'"&gt;用户是经理&lt;/p&gt; &lt;p th:case="*"&gt;用户是别的玩意&lt;/p&gt;&lt;/div&gt; 需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。 另外th:case=&quot;*&quot;表示默认，放最后。 页面： 4.10.JS模板模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来： &lt;script th:inline="javascript"&gt; const user = /*[[$&#123;user&#125;]]*/ &#123;&#125;; const age = /*[[$&#123;user.age&#125;]]*/ 20; console.log(user); console.log(age)&lt;/script&gt; 在script标签中通过th:inline=&quot;javascript&quot;来声明这是要特殊处理的js脚本 语法结构： const user = /*[[Thymeleaf表达式]]*/ "静态环境下的默认值"; 因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。 看看页面的源码： 我们的User对象被直接处理为json格式了，非常方便。 控制台：]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一异常处理]]></title>
    <url>%2Fposts%2Ff118268a%2F</url>
    <content type="text"><![CDATA[统一的响应结果类型​ 在实际的spring boot项目开发过程中，我们后端要返回统一的Json数据格式给前端，便于前端对数据的处理。通常情况下，后端返回给前端的数据类型都是包含操作代码、返回信息、操作是否成功字段，例如： /** * 统一的响应结果类 *///lombok注解@Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息&#125; 如果有其他字段需求，如时间戳、返回的类型可以对上面的统一响应结果类进行继承。例如： @Data@NoArgsConstructor@AllArgsConstructor@Getterpublic class ObjectResponseResult extends ResponseResult &#123; private Date date; private Object data; &#125; 自定义错误代码： 每个业务操作的异常使用异常代码去标识。 错误代码接口，里面定义三个基本的抽象方法。 public interface ResultCode &#123; //操作是否成功,true为成功，false操作失败 boolean success(); //操作代码 int code(); //提示信息 String message();&#125; 公共的错误代码枚举类，实现了错误代码接口，里面的三个字段和ResponseResult一致： @ToStringpublic enum CommonCode implements ResultCode &#123; SUCCESS(true,10000,"操作成功！"), FAIL(false,11111,"操作失败！"), SERVER_ERROR(false,11011,"抱歉，系统繁忙，请稍后重试！"), REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"), ARGS_ERROR(false,10003,"参数错误！"); ; //操作是否成功 boolean success; //操作代码 int code; //提示信息 String message; CommonCode(boolean success, int code, String message) &#123; this.success=success; this.code=code; this.message=message; &#125; @Override public boolean success() &#123; return success; &#125; @Override public int code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 为了方便拿到指自定义的错误代码枚举类中的信息，可以在ResponseResult类中添加构造方法,并且初始化两种响应结果成功和失败： @Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息 public ResponseResult(ResultCode resultCode)&#123; this.success=resultCode.success(); this.code=resultCode.code(); this.message=resultCode.message(); &#125; public static ResponseResult SUCCESS()&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; public static ResponseResult FAIL()&#123; return new ResponseResult(CommonCode.FAIL); &#125;&#125; 统一的异常处理系统对异常的处理使用统一的异常处理流程 自定义异常类型。 自定义错误代码及错误信息。 对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较 齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。 对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 RuntimeException类型（运行时异常）。 可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随 请求响应给客户端。 异常的类型 可预知的异常：程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，例如判断用户为空时，抛出自定义异常，异常的错误信息可以写“用户为空” 不可预知的异常：由SpringMVC统一捕获Exception类型的异常。 异常抛出及处理流程 在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 统一由异常捕获类捕获异常，并进行处理 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误 信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为11011错误代码并响应给用户 将错误代码及错误信息以Json格式响应给用户。 可预知异常处理自定义异常类 ** * 自定义异常类（可预知的异常） */public class MyException extends RuntimeException &#123; ResultCode resultCode;//错误代码 public MyException(ResultCode resultCode)&#123; this.resultCode=resultCode; &#125; public ResultCode getResultCode()&#123; return resultCode; &#125;&#125; 抛出异常类 每次抛出自定义异常都要写：throw new MyException(错误代码);为了简便书写，可以将抛出的自定义异常进行封装 public class ExceptionCast &#123; //将抛出的自定义异常进行封装 public static void Cast(ResultCode resultCode)&#123; throw new MyException(resultCode); &#125;&#125; 异常捕获类 使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常 /** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125;&#125; 注：因为返回的结果为Json格式的数据，需要上@ResponseBody注解，如果不写@ResponseBody注解可以将@ControllerAdvice注解改为@RestControllerAdvice，@RestController=@Controller+@ResponseBody 异常处理测试： 在controller、service、dao中都可以抛出异常 @RestController@RequestMapping("/index")public class indexController &#123; @GetMapping("/&#123;id&#125;") public ResponseResult findById(@PathVariable String id)&#123; if(id.equals("123")&#123; ExceptionCast.Cast(CommonCode.FAIL); &#125; return ResponseResult.SUCCESS(); &#125;&#125; 使用postman测试，结果： Get:http://localhost:8888/index/1 &#123; "success": true, "code": 10000, "message": "操作成功！"&#125; Get:http://localhost:8888/index/123 &#123; "success": false, "code": 10003, "message": "参数错误！"&#125; 不可预知异常处理​ 当以put方式请求http://localhost:8888/index/1 时，SpringMVC会如下异常： org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported 具体的响应信息： &#123; "timestamp": "2019-08-12T13:44:21.910+0000", "status": 405, "error": "Method Not Allowed", "message": "Request method 'PUT' not supported", "trace": "xxxx..........", "path": "/index/1"&#125; 此时的响应信息前端是无法进行解析的。 在异常捕获类中添加对Exception类异常的捕获： //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); return new ResponseResult(CommonCode.SERVER_ERROR); &#125; 再进行测试，响应的结果如下： &#123; "success": false, "code": 11011, "message": "抱歉，系统繁忙，请稍后重试！"&#125; 虽然对SpringMVC报的异常进行捕获了，但是响应的结果都是“抱歉，系统繁忙，请稍后重试！”。 当我们以非Get方式请求http://localhost:8888/index/1 时，我们希望响应的结果是“请求方式错误！” 针对上面的问题其解决的方法是： 在map中配置Exception类和ResultCode（上述的错误代码类） 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型和错误代码，如果存在错误代码则返回此错误代码，否则返回11011（“抱歉，系统繁忙，请稍后重试！”）错误。 具体实现如下： 在通用错误代码类CommonCode中添加请求方式错误异常。 REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"); 在异常捕获类中定义map类型的异常，key为异常类型，value为错误代码，将SpingMVC抛出的异常类添加到map中，在捕获Exception类异常时取出map中的错误代码ResultCode，最后返回响应结果。捕获异常类完整代码： package com.myblog.exception;import com.google.common.collect.ImmutableMap;import com.myblog.model.response.CommonCode;import com.myblog.model.response.ResponseResult;import com.myblog.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.HashMap;import java.util.Map;/** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125; static Map&lt;Class&lt;?extends Throwable&gt;,ResultCode&gt; exceptionMap=new HashMap&lt;&gt;(); //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); ResultCode resultCode=exceptionMap.get(exception.getClass()); if(resultCode!=null)&#123; return new ResponseResult(resultCode); &#125; return new ResponseResult(CommonCode.SERVER_ERROR); &#125; //在这里加入一些基础的异常类型判断 static &#123; //springmvc报异常：org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported，将HttpRequestMethodNotSupportedException添加到exceptionMap中。 exceptionMap.put(HttpRequestMethodNotSupportedException.class,CommonCode.REQUEST_METHOD_ERROR); &#125;&#125; 测试： 用PUT方式（或者其他非Get方式）请求：http://localhost:8888/index/1 响应结果： &#123; &quot;success&quot;: false, &quot;code&quot;: 10002, &quot;message&quot;: &quot;请求方式错误！&quot;&#125; ​]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
