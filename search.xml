<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker上安装Elasticsearch]]></title>
    <url>%2F2019%2F09%2F24%2FDocker%E4%B8%8A%E5%AE%89%E8%A3%85Elasticsearch%2F</url>
    <content type="text"><![CDATA[1.Elasticsearch安装1.1 拉取镜像 docker pull ElasticSearch 1.2 创建并启动容器 清理内存： 释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）: syncecho 3 &gt; /proc/sys/vm/drop_caches 启动容器： # docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name &lt;容器名称&gt; &lt;镜像ID&gt; ElasticSearch是用Java写的，它默认会占用2GB的堆内存空间，-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;限制内存为256MB docker ps查看 docker logs &lt;容器ID&gt;查看日志信息，可能会报如下错误（再次docker ps会发现elasticsearch没有启动） 解决方法： 切换到root用户修改配置sysctl.conf # vi /etc/sysctl.conf 添加配置： # vm.max_map_count=655360 并执行命令： # sysctl -p docker start &lt;容器ID&gt;重新启动elasticsearch，即可启动成功。 1.3 检查 浏览器URL地址输入&lt;ip地址&gt;：9200，会出现如下JSON格式的数据。 1.4 Java 使用 9300 端口连接ES 会出现如下错误 NoNodeAvailableException[None of the configured nodes are available:[&#123;#transport#‐1&#125;&#123;exvgJLR‐RlCNMJy‐hzKtnA&#125;&#123;xxxx&#125;&#123;xxxx&#125;]]at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodes AreAvailableat org.elasticsearch.client.transport.TransportClientNodesService.executeat org.elasticsearch.client.transport.TransportProxyClient.execute 解决方法： 拷贝配置文件到宿主机（docker中的elasticsearch容器必须是启动的）： # docker cp &lt;容器ID&gt;:/usr/share/elasticsearch/config/elasticsearch.yml /usr/local/elasticsearch/elasticsearch.yml 停止elasticsearch容器并删除它 # docker stop &lt;容器ID&gt; 查看停止的容器： # docker ps -a 删除容器 # docker rm -f &lt;容器ID&gt; 重新创建容器，此时需要挂载文件 # docker run -di -e ES_JAVA_OPTS="-Xms256m -Xmx256m" --name=&lt;容器名称&gt; -p 9200:9200 -p 9300:9300 -v /usr/local/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.5.0 在/usr/local/elasticsearch/elasticsearch.yml文件中添加transport.host: 0.0.0.0，配置如下： cluster.name: "docker-cluster"network.host: 0.0.0.0transport.host: 0.0.0.0# minimum_master_nodes need to be explicitly set when bound on a public IP# set to 1 to allow single node clusters# Details: https://github.com/elastic/elasticsearch/pull/17288discovery.zen.minimum_master_nodes: 1#允许跨域http.cors.enabled: truehttp.cors.allow-origin: "*" 2. 安装IK中文分词器 从github下载ik，下载地址：(注意：IK分词器的版本和elasticsearch的版本要一致) https://github.com/medcl/elasticsearch-analysis-ik/releases 下载解压复制到宿主机 /usr/local/elasticsearch目录下 进入/usr/local/elasticsearch`目录 # cd /usr/local/elasticsearch 复制到elasticsearch容器中 # docker cp elasticsearch-analysis-ik-6.5.0 &lt;容器ID&gt;:/usr/share/elasticsearch/plugins 重启elasticsearch容器 # docker restart &lt;容器ID&gt; 检查是否安装成功： PUT http://&lt;你的ip&gt;:9200/_analyze&#123; "analyzer":"ik_smart", "text":"中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首"&#125; 结果如下： &#123; "tokens": [ &#123; "token": "中国", "start_offset": 0, "end_offset": 2, "type": "CN_WORD", "position": 0 &#125;, &#123; "token": "驻", "start_offset": 2, "end_offset": 3, "type": "CN_CHAR", "position": 1 &#125;, &#123; "token": "洛杉矶", "start_offset": 3, "end_offset": 6, "type": "CN_WORD", "position": 2 &#125;, &#123; "token": "领事馆", "start_offset": 6, "end_offset": 9, "type": "CN_WORD", "position": 3 &#125;, &#123; "token": "遭", "start_offset": 9, "end_offset": 10, "type": "CN_CHAR", "position": 4 &#125;, &#123; "token": "亚裔", "start_offset": 10, "end_offset": 12, "type": "CN_WORD", "position": 5 &#125;, &#123; "token": "男子", "start_offset": 12, "end_offset": 14, "type": "CN_WORD", "position": 6 &#125;, &#123; "token": "枪击", "start_offset": 14, "end_offset": 16, "type": "CN_WORD", "position": 7 &#125;, &#123; "token": "嫌犯", "start_offset": 17, "end_offset": 19, "type": "CN_WORD", "position": 8 &#125;, &#123; "token": "已", "start_offset": 19, "end_offset": 20, "type": "CN_CHAR", "position": 9 &#125;, &#123; "token": "自首", "start_offset": 20, "end_offset": 22, "type": "CN_WORD", "position": 10 &#125; ]&#125; 3.出现的问题及解决方法 cluster block exception： &#123; "error": &#123; "root_cause": [ &#123; "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125; ], "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125;, "status": 403&#125; 解决方法： PUT http://&lt;你的IP&gt;:9200/_all/_settings&#123; "index.blocks.read_only_allow_delete": null&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一异常处理]]></title>
    <url>%2F2019%2F09%2F24%2Fspring%20boot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[统一的响应结果类型​ 在实际的spring boot项目开发过程中，我们后端要返回统一的Json数据格式给前端，便于前端对数据的处理。通常情况下，后端返回给前端的数据类型都是包含操作代码、返回信息、操作是否成功字段，例如： /** * 统一的响应结果类 *///lombok注解@Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息&#125; 如果有其他字段需求，如时间戳、返回的类型可以对上面的统一响应结果类进行继承。例如： @Data@NoArgsConstructor@AllArgsConstructor@Getterpublic class ObjectResponseResult extends ResponseResult &#123; private Date date; private Object data; &#125; 自定义错误代码： 每个业务操作的异常使用异常代码去标识。 错误代码接口，里面定义三个基本的抽象方法。 public interface ResultCode &#123; //操作是否成功,true为成功，false操作失败 boolean success(); //操作代码 int code(); //提示信息 String message();&#125; 公共的错误代码枚举类，实现了错误代码接口，里面的三个字段和ResponseResult一致： @ToStringpublic enum CommonCode implements ResultCode &#123; SUCCESS(true,10000,"操作成功！"), FAIL(false,11111,"操作失败！"), SERVER_ERROR(false,11011,"抱歉，系统繁忙，请稍后重试！"), REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"), ARGS_ERROR(false,10003,"参数错误！"); ; //操作是否成功 boolean success; //操作代码 int code; //提示信息 String message; CommonCode(boolean success, int code, String message) &#123; this.success=success; this.code=code; this.message=message; &#125; @Override public boolean success() &#123; return success; &#125; @Override public int code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 为了方便拿到指自定义的错误代码枚举类中的信息，可以在ResponseResult类中添加构造方法,并且初始化两种响应结果成功和失败： @Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息 public ResponseResult(ResultCode resultCode)&#123; this.success=resultCode.success(); this.code=resultCode.code(); this.message=resultCode.message(); &#125; public static ResponseResult SUCCESS()&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; public static ResponseResult FAIL()&#123; return new ResponseResult(CommonCode.FAIL); &#125;&#125; 统一的异常处理系统对异常的处理使用统一的异常处理流程： 自定义异常类型。 自定义错误代码及错误信息。 对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较 齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。 对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 RuntimeException类型（运行时异常）。 可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随 请求响应给客户端。 异常的类型： 可预知的异常：程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，例如判断用户为空时，抛出自定义异常，异常的错误信息可以写“用户为空” 不可预知的异常：由SpringMVC统一捕获Exception类型的异常。 异常抛出及处理流程： 在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 统一由异常捕获类捕获异常，并进行处理 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误 信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为11011错误代码并响应给用户 将错误代码及错误信息以Json格式响应给用户。 可预知异常处理:自定义异常类： ** * 自定义异常类（可预知的异常） */public class MyException extends RuntimeException &#123; ResultCode resultCode;//错误代码 public MyException(ResultCode resultCode)&#123; this.resultCode=resultCode; &#125; public ResultCode getResultCode()&#123; return resultCode; &#125;&#125; 抛出异常类： 每次抛出自定义异常都要写：throw new MyException(错误代码);为了简便书写，可以将抛出的自定义异常进行封装 public class ExceptionCast &#123; //将抛出的自定义异常进行封装 public static void Cast(ResultCode resultCode)&#123; throw new MyException(resultCode); &#125;&#125; 异常捕获类： 使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常 /** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125;&#125; 注：因为返回的结果为Json格式的数据，需要上@ResponseBody注解，如果不写@ResponseBody注解可以将@ControllerAdvice注解改为@RestControllerAdvice，@RestController=@Controller+@ResponseBody 异常处理测试： 在controller、service、dao中都可以抛出异常 @RestController@RequestMapping("/index")public class indexController &#123; @GetMapping("/&#123;id&#125;") public ResponseResult findById(@PathVariable String id)&#123; if(id.equals("123")&#123; ExceptionCast.Cast(CommonCode.FAIL); &#125; return ResponseResult.SUCCESS(); &#125;&#125; 使用postman测试，结果： Get:http://localhost:8888/index/1 &#123; "success": true, "code": 10000, "message": "操作成功！"&#125; Get:http://localhost:8888/index/123 &#123; "success": false, "code": 10003, "message": "参数错误！"&#125; 不可预知异常处理：​ 当以put方式请求http://localhost:8888/index/1 时，SpringMVC会如下异常： org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported 具体的响应信息： &#123; "timestamp": "2019-08-12T13:44:21.910+0000", "status": 405, "error": "Method Not Allowed", "message": "Request method 'PUT' not supported", "trace": "xxxx..........", "path": "/index/1"&#125; 此时的响应信息前端是无法进行解析的。 在异常捕获类中添加对Exception类异常的捕获： //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); return new ResponseResult(CommonCode.SERVER_ERROR); &#125; 再进行测试，响应的结果如下： &#123; "success": false, "code": 11011, "message": "抱歉，系统繁忙，请稍后重试！"&#125; 虽然对SpringMVC报的异常进行捕获了，但是响应的结果都是“抱歉，系统繁忙，请稍后重试！”。 当我们以非Get方式请求http://localhost:8888/index/1 时，我们希望响应的结果是“请求方式错误！” 针对上面的问题其解决的方法是： 在map中配置Exception类和ResultCode（上述的错误代码类） 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型和错误代码，如果存在错误代码则返回此错误代码，否则返回11011（“抱歉，系统繁忙，请稍后重试！”）错误。 具体实现如下： 在通用错误代码类CommonCode中添加请求方式错误异常。 REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"); 在异常捕获类中定义map类型的异常，key为异常类型，value为错误代码，将SpingMVC抛出的异常类添加到map中，在捕获Exception类异常时取出map中的错误代码ResultCode，最后返回响应结果。捕获异常类完整代码： package com.myblog.exception;import com.google.common.collect.ImmutableMap;import com.myblog.model.response.CommonCode;import com.myblog.model.response.ResponseResult;import com.myblog.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.HashMap;import java.util.Map;/** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125; static Map&lt;Class&lt;?extends Throwable&gt;,ResultCode&gt; exceptionMap=new HashMap&lt;&gt;(); //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); ResultCode resultCode=exceptionMap.get(exception.getClass()); if(resultCode!=null)&#123; return new ResponseResult(resultCode); &#125; return new ResponseResult(CommonCode.SERVER_ERROR); &#125; //在这里加入一些基础的异常类型判断 static &#123; //springmvc报异常：org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported，将HttpRequestMethodNotSupportedException添加到exceptionMap中。 exceptionMap.put(HttpRequestMethodNotSupportedException.class,CommonCode.REQUEST_METHOD_ERROR); &#125;&#125; 测试： 用PUT方式（或者其他非Get方式）请求：http://localhost:8888/index/1 响应结果： &#123; &quot;success&quot;: false, &quot;code&quot;: 10002, &quot;message&quot;: &quot;请求方式错误！&quot;&#125; ​]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
