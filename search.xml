<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RESTful API的拦截机制]]></title>
    <url>%2Fposts%2Ff2020793%2F</url>
    <content type="text"><![CDATA[前言在某些场景下，我们需要去对RESTful API做一些统一的处理，例如，我希望所有的RESTful API去记录服务处理的时间，那么如何实现这样的需求呢？这就 用到RESTful API的拦截机制。 最常见的三种RESTful API的拦截机制： 过滤器（Filter） 拦截器（Interceptor） 切片（Aspect） 过滤器（Filter） 首先创建一个SpringBoot项目，端口设为：7010，创建一个Controller类 @RestController@RequestMapping("/users")public class UserController &#123; @GetMapping public void index()&#123; System.out.println("服务执行..."); &#125;&#125; 创建一个TimeFilter的类，让其实现javax.Servlet.Filter接口 @Componentpublic class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("Time Filter init..."); &#125; @Override public void doFilter(ServletRequest req, ServletResponse resp, chain filterChain) throws IOException, ServletException &#123; System.out.println("Time Filter Start..."); long start=System.currentTimeMillis(); chain.doFilter(req,resp); System.out.println("耗时："+(System.currentTimeMillis()-start)); System.out.println("Time Filter finish..."); &#125; @Override public void destroy() &#123; System.out.println("Time Filter destroy..."); &#125;&#125; 运行启动类访问 http://localhost:7010/users，观察控制台输出 2019-06-10 16:08:07.068 INFO 16804 — [ restartedMain] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 804 msTime Filter init...2019-06-10 16:08:07.198 INFO 16804 — [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService ‘applicationTaskExecutor’2019-06-10 16:08:07.299 INFO 16804 — [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292019-06-10 16:08:07.329 INFO 16804 — [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 7010 (http) with context path ‘’2019-06-10 16:08:07.331 INFO 16804 — [ restartedMain] c.g.s.hello.HelloApplication : Started HelloApplication in 1.392 seconds (JVM running for 2.451)2019-06-10 16:08:19.649 INFO 16804 — [nio-7010-exec-1] o.apache.tomcat.util.http.parser.Cookie : A cookie header was received [1571560616,1572086143; _gid=GA1.1.1871813766.1572086143] that contained an invalid cookie. That cookie will be ignored. Note: further occurrences of this error will be logged at DEBUG level.2019-06-10 16:08:19.653 INFO 16804 — [nio-7010-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet ‘dispatcherServlet’2019-06-10 16:08:19.653 INFO 16804 — [nio-7010-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet ‘dispatcherServlet’2019-06-10 16:08:19.660 INFO 16804 — [nio-7010-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 6 msTime Filter Start...服务执行...耗时：20Time Filter finish... 可以看出过滤器执行的流程：首先加了 @Component后，TimeFilter就被加入Spring容器中，容器创建和示例时，执行过滤器类中的init()方法；当用户请求访问与过滤器关联的URL时（上述代码关联的url路径时/*），web容器将先调用过滤器的doFilter（）方法，FilterChain方法参数可以调用chain.doFilter（）方法，将请求传给下一个过滤器（或目标资源），或利用转发、重定向请求转发到其他资源；当web容器在销毁过滤器实例前调用destroy()方法，在这个方法中可以释放过滤器占用的资源。 需求：如果我们需要使用第三方的过滤器，第三方过滤器没有声明@Component注解，我们应该如何将第三方过滤器加入我们的项目呢？在传统的JavaWeb项目中，我们可以把过滤器配置到web.xml配置文件中，但是Spring Boot没有XML配置文件，我们该如何将第三方的过滤器加入到我们的项目中去呢？既然Spring Boot不提供XML配置文件，我们可以写配置类，下面将介绍如何将第三方过滤器加入到我们的项目中去。 ​ 将上面的TimeFilter类的从@Component注解去掉，假设它一个第三方过滤器， ​ 首先建一个配置类,我们需要把TimeFilter类加入到过滤器链中去。 @Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter()&#123; //创建过滤器注册类 FilterRegistrationBean filterRegistrationBean=new FilterRegistrationBean(); TimeFilter timeFilter=new TimeFilter(); //将TimeFilter注册到过滤器注册类中 filterRegistrationBean.setFilter(timeFilter); List&lt;String&gt; urls=new ArrayList&lt;&gt;(); urls.add("/users"); //添加过滤器的URL模式 filterRegistrationBean.setUrlPatterns(urls); return filterRegistrationBean; &#125;&#125; 拦截器（Interceptor）​ 使用过滤器（Filter）的拦截机制存在一些缺点：它只能拿到Http的请求和响应，只能从请求和响应中拿到一些参数，用户发送的URL请求是由哪个控制器类的哪个方法来处理的，在Filter里它是不知道的，因为 javax.Servlet.Filter接口是由J2EE 规范来定义的，J2EE规范并不了解与Spring相关的任何东西，如果需要用到SpringMVC中的控制器类或控制器类中的方法时，我们就需要使用到Spring框架的拦截器。 创建一个拦截器类，实现 HandlerInterceptor接口 @Componentpublic class TimeInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle..."); System.out.println(((HandlerMethod)handler).getBean().getClass().getName()); System.out.println(((HandlerMethod)handler).getMethod().getName()); request.setAttribute("startTime",System.currentTimeMillis()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle..."); long start=(long) request.getAttribute("startTime"); System.out.println("耗时："+(System.currentTimeMillis()-start)); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion..."); System.out.println("异常："+ex); long start=(long) request.getAttribute("startTime"); System.out.println("耗时："+(System.currentTimeMillis()-start)); &#125;&#125; 拦截器比过滤器的优势就体现出来了，它比过滤器多了一个Object类型的参数，利用反射可以得到执行的类和方法。 preHandle（）：Controller类中的某个方法被调用之前执行这个方法； postHandle（）：controller类中的方法执行后会调用这个方法，如果preHandle返回false不执行该方法，如果controller类中的方法抛出异常这样方法将不执行； afterCompletion（）：无论controller类中方法正常执行还是抛出异常,成功执行ex为null ，controller类中方法抛出异常时ex为抛出的异常。 要使拦截器类生效，需要在配置类中将它注册为一个拦截器 @Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor); &#125;&#125; 切片（Aspect）用户发送的URL请求时，虽然拦截器能够拿到URL请求对应的控制器类和方法，但是方法的参数却不能拿到，所以这时我们就要使用切片。 切入点：在哪些方法上起作用，在什么时候起作用 增强方法：起作用时执行的业务逻辑 常用注解： @Aspect: 声明该类为一个切片 @Before()： 相当于拦截器的 preHandle() @After() ： 相当于拦截器的postHandle() @AfterThrowing ： 相当于拦截器的afterCompletion() @Around() ：包括以上三点，所以一般使用它. 首先在控制器类定义一个方法 @RestController@RequestMapping("/users")public class UserController &#123; @GetMapping("/&#123;id&#125;") public String getUserInfo(@PathVariable Integer id)&#123; System.out.println("id:"+id); return "查询id为"+id+"的用户"; &#125;&#125; 定义一个切片 @Aspect@Componentpublic class TimeAspect &#123; @Around("execution(* cn.ghjcloud.springsecurity.hello.controller.UserController.*(..))") public Object handleControllerMethod(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("time aspect start..."); Object[] args=pjp.getArgs(); for (Object arg : args) &#123; System.out.println("参数："+arg); &#125; long start=System.currentTimeMillis(); Object obj=pjp.proceed(); System.out.println("耗时："+(System.currentTimeMillis()-start)); System.out.println("time aspect end..."); return obj; &#125;&#125; ProceedingJoinPoint pjp :包含拦截方法的一些信息的对象 pjp.getArgs()：获取所有参数的值 pjp.proceed()：执行拦截的方法，获取拦截方法的返回值的对象 总结三者的特点： 过滤器：能够拿到原始的HTTP请求和响应信息，但是拿不到处理请求的方法的信息； 拦截器：它既可以拿到HTTP请求和响应信息，也可以拿到处理请求的方法的信息，但是它不能拿到请求方法被调用的参数值； 切片：不能够拿到HTTP请求和响应信息，但是能够拿到请求方法被真正调用时传递的参数值。 拦截顺序： 如果三者对controller类的同一个方法进行拦截时，被拦截的方法不会执行三次，它只会执行一次，并且Filter、Interceptor、Aspect的作用顺序是：Filter&rarr;Interceptor&rarr;Aspect，只有这三者执行通过后才会进入controller类中执行方法； 如果controller类中的方法抛出异常，捕获异常的顺序是：Aspect&rarr; ControllerAdvice &rarr; Interceptor &rarr; Filter ，如果 Aspect没捕获异常就将异常抛给ControllerAdvice ……,如果最后Filter没有处理异常，就会将异常抛给Tomcat返回给用户。]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API]]></title>
    <url>%2Fposts%2F22ef0a2a%2F</url>
    <content type="text"><![CDATA[前言RESTful架构，就是目前流行的一种互联网软件架构。它结构清晰、符合标准、易 于理解、扩展方便，所以正得到越来越多网站的采用。REST一词，是由Roy Thomes Fielding（HTTP协议(v1.0和v1.1)的主要设计者、Apache服务器作者之一、Apache基金会第一任主席）在他2000年的博士论文中提出的。 什么是RESTREST 是Representational State Transfer的缩写，翻译是”表现层状态转化”。 简单来说，就是用URI表示资源，用HTTP方法(GET, POST, PUT, DELETE等)表示对这些资源的操作。 Resource: 资源，即数据，存在互联网上的可被访问的实体 Representation： 数据的某种表现形式，如HTML, JSON。 State Transfer：状态变化，HTTP方法实现 面向资源是REST明显的特征，对于同一个资源的一组不同的操作。资源是服务器 上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。REST要 求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。 REST是设计风格而不是标准 什么是RESTful百度百科给出的解释：RESTful是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。 基于REST构建的API就是Restful风格。 RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。 为什么使用RESTful在前后端不分离时代，前端开发人员将开发好了前端HTML页面，后端开发人员需要将前端的HTML页面改成JSP或者Thymeleaf等模板引擎的页面，甚至有时候还会添加或者修改一些JS代码，使得后端人员不能专注于后端的业务开发，严重影响了产品的开发效率。随着前后端分离时代的来临，使用RESTful，前后端规定一套统一的响应结构，可以使得产品开发是一个并行的模式，加大了开发的效率和开发周期。 现在的客户端种类很多，例如，Android、IOS、PC端等，RESTful可以 通过统一的接口为这些客客户端提供服务，这样的接口只需要提供数据而用提供前端样式。 传统的URL和RESTful 风格对用户进行增删改查传统的URL和RESTful风格之间的比较 传统的URL风格： 方法 传统的URL Http请求 查询 /user/find?id=1 GET 新增 /user/add?name=”zhangsan” POST 修改 /user/edit?id=2&amp;name=”lisi” POST 删除 /user/delete?id=1 GET RESTful风格： 方法 RESTful风格的URL Http请求 查询 /user/1 GET 新增 /user POST 修改 /user/1 PUT 删除 /user/1 DELETE url：传统的URL风格更多的是描述了请求的动作行为，而RESTful风格的url描述的是资源。 例如，REStful风格的查询、修改和删除url都是一样的，都是对用户id为1的用户执行不同操作，而 用户就是系统中的资源。 http请求方式：在传统的URL风格POST请求一般用来新增和修改，因为修改和删除参数一般很长，而GET方式的请求不能传输超过4000字节的数据，RESTful风格使用http请求描述不同的行为，使用状态码描述不同的结果。 数据交互方式：传统的URL使用的是Http参数进行数据传输，而RESTful风格的URL使用的是Json进行数据交互。 如何实现RESTful风格的API 协议 API与用户的通信协议，总是使用HTTPs协议。 域名 将api部署在专用域名下： http://api.example.com 或者将api放在主域名下： http://www.example.com/api/ 版本 将API的版本号放在url中。 http://www.example.com/api/v1 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径 路径表示API的具体网址。每个网址代表一种资源。 资源作为网址，网址中不能有动词只能有名词，一般名词要与数据库 的表名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以名词要使用复数。 正确示例： http://www.example.com/api/v1/employees 错误示例： http://www.example.com/api/v1/employee http://www.example.com/api/v1/add/employee HTTP动词 对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 两个个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 示例： GET /employees : 查询所有员工 GET /employees/ID ：查询某个员工 GET /employees/ID/roles ：查询某个员工所属的角色 POST /employees : 新建一个员工 PUT / employees/ID ： 更新某个员工的信息（需要提供该员工的所有信息） PATCH /employees/ID ： 更新某个员工的信息（需要提供该员工的部分信息） DELETE /employees/ID：删除某个员工 过滤信息 如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 常用的参数： ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;size=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 状态码 服务器向用户返回的状态码和提示信息，常用的有： 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 自定义错误处理 服务器返回的错误信息，以键值对的形式返回 &#123; error:'Invalid API KEY'&#125; 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 使用链接关联相关资源 在返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 &#123;"link": &#123; "rel": "collection https://www.example.com/employees", "href": "https://api.example.com/employees", "title": "List of employees", "type": "application/vnd.yourformat+json"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 其他 API的身份认证应该使用OAuth 2.0框架。 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 参考文档http://www.ruanyifeng.com/blog/2011/09/restful.html http://www.ruanyifeng.com/blog/2014/05/restful_api.html]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis查询树形结构数据]]></title>
    <url>%2Fposts%2Fe8e2ee81%2F</url>
    <content type="text"><![CDATA[数据表的设计创建数据表对于树形结构的数据库设计通常是基于继承关系设计的，也就是通过父ID关联来实现的。 一张树形结构的数据表基本的三个字段：id（自己）、name（名称）和parentid（父类编号） CREATE TABLE `tree` ( `id` int(20) NOT NULL COMMENT &apos;id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;名称&apos;, `parentid` int(20) NOT NULL COMMENT &apos;父id&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据INSERT INTO `tree` VALUES (&apos;100&apos;, &apos;一级1&apos;, &apos;0&apos;);INSERT INTO `tree` VALUES (&apos;101&apos;, &apos;一级2&apos;, &apos;0&apos;);INSERT INTO `tree` VALUES (&apos;201&apos;, &apos;二级1-1&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;202&apos;, &apos;二级1-2&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;203&apos;, &apos;二级1-3&apos;, &apos;100&apos;);INSERT INTO `tree` VALUES (&apos;211&apos;, &apos;二级2-1&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;212&apos;, &apos;二级2-2&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;213&apos;, &apos;二级2-3&apos;, &apos;101&apos;);INSERT INTO `tree` VALUES (&apos;301&apos;, &apos;三级1-1-1&apos;, &apos;201&apos;);INSERT INTO `tree` VALUES (&apos;302&apos;, &apos;三级1-1-2&apos;, &apos;201&apos;);INSERT INTO `tree` VALUES (&apos;311&apos;, &apos;三级1-2-1&apos;, &apos;202&apos;);INSERT INTO `tree` VALUES (&apos;321&apos;, &apos;三级2-1-1&apos;, &apos;211&apos;);INSERT INTO `tree` VALUES (&apos;322&apos;, &apos;三级2-1-2&apos;, &apos;211&apos;);INSERT INTO `tree` VALUES (&apos;331&apos;, &apos;三级2-2-1&apos;, &apos;212&apos;); 实体类@Data@NoArgsConstructor@ToStringpublic class Tree implements Serializable &#123; private Integer id;//id private String name;//名称 private Integer parentid;//父id private List&lt;Tree&gt; children=new ArrayList&lt;&gt;();//孩子 private static final long serialVersionUID = 1L;&#125; 实现方式无论是通过Mybatis的递归查询还是通过代码的递归查询方式其思路都是一致的。 先查询出所有一级节点 再跟进一级节点递归查询出其所有子节点 基于MyBatis的递归查询基于注解 持久层接口： @Mapperpublic interface TreeMapper &#123; @Select("select * from tree where parentid=#&#123;parentId&#125;") //根据父id查询出所有孩子 @Results(&#123; @Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="parentid",column="parentid"), @Result(property="children",column="id",javaType=java.util.List.class, many=@Many(select="cn.ghjcloud.tree.dao.TreeMapper.selectChildrenByPId")) //column为父节点Id &#125;) List&lt;Tree&gt; selectChildrenByPId(Integer parentId); @Select("select * from tree where parentid=0") //查询出所有一级目录 @Results(&#123; @Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="parentid",column="parentid"), @Result(property="children",column="id",javaType=java.util.List.class, many=@Many(select="cn.ghjcloud.tree.dao.TreeMapper.selectChildrenByPId")) &#125;) List&lt;Tree&gt; selectTreeList();&#125; 基于XML TreeMapper.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ghjcloud.tree.dao.TreeMapper"&gt; &lt;resultMap id="BaseResultMap" type="cn.ghjcloud.tree.model.Tree"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="parentid" jdbcType="INTEGER" property="parentid" /&gt; &lt;collection property="children" column="id" javaType="java.util.List" ofType="cn.ghjcloud.tree.model.Tree" select="selectChildrenByPId"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectChildrenByPId" resultMap="BaseResultMap"&gt; select * from tree where parentid=#&#123;parentId&#125; &lt;/select&gt; &lt;select id="selectTreeList" resultMap="BaseResultMap"&gt; select * from tree where parentid=0 &lt;/select&gt;&lt;/mapper&gt; 接口： @Mapperpublic interface TreeMapper &#123; List&lt;Tree&gt; selectChildrenByPId(Integer parentId); List&lt;Tree&gt; selectTreeList();&#125; 注解对应的XML的元素 注解 xml @Results resultMap @Result Result @Many collection column:实体类中对应的属性 property：mysql表中的字段 基于代码的递归查询根据某个父节点递归获取子节点 /** * 根据某个父节点递归获取子节点 * @param parentTree 父节点 * @param list 全部节点 * @return */public Tree getChildrenByPId(Tree parentTree,List&lt;Tree&gt; list)&#123; list.forEach((tree)-&gt;&#123; if(tree.getParentid().equals(parentTree.getId()))&#123; tree=getChildrenByPId(tree,list); parentTree.getChildren().add(tree); &#125; &#125;); return parentTree;&#125; 先获取所有一级节点，再调用上面的getChildrenByPId( )方法递归查询出所有子节点 /** * 递归获取树形结构的数据 * @param list 全部节点 * @return */ private List&lt;Tree&gt; getTreeList(List&lt;Tree&gt; list)&#123; List&lt;Tree&gt; treeList=new ArrayList&lt;&gt;(); list.forEach((tree -&gt; &#123; //获取所有一级节点 if(tree.getParentid()==0)&#123; treeList.add(tree); &#125; &#125;)); // 递归获取子节点 treeList.forEach((parentTree)-&gt;&#123; parentTree=this.getChildrenByPId(parentTree,list); &#125;); return treeList; &#125; 测试基于MyBatis的递归查询service层@Servicepublic class TreeService &#123; @Autowired private TreeMapper treeMapper; public List&lt;Tree&gt; selectTreeList()&#123; List&lt;Tree&gt; trees=treeMapper.selectTreeList(); return trees; &#125;&#125; Controller层@RestController@RequestMapping("/tree")public class TreeController &#123; @Autowired private TreeService treeService; @GetMapping("/list") public ResponseEntity&lt;List&lt;Tree&gt;&gt; selectTreeList()&#123; return ResponseEntity.ok(treeService.selectTreeList()); &#125;&#125; 基于代码的递归查询Mapper接口@Repositorypublic interface TreeMapper extends Mapper&lt;Tree&gt; &#123;&#125; Service层@Servicepublic class TreeService &#123; @Autowired private TreeMapper treeMapper; public List&lt;Tree&gt; findTreeList()&#123; //获取所有节点 List&lt;Tree&gt; list=treeMapper.selectAll(); List&lt;Tree&gt; treeList=this.getTreeList(list); return treeList; &#125; /** * 递归获取树形结构的数据 * @param list 全部节点 * @return */ private List&lt;Tree&gt; getTreeList(List&lt;Tree&gt; list)&#123; List&lt;Tree&gt; treeList=new ArrayList&lt;&gt;(); list.forEach((tree -&gt; &#123; //获取所有一级节点 if(tree.getParentid()==0)&#123; treeList.add(tree); &#125; &#125;)); // 递归获取子节点 treeList.forEach((parentTree)-&gt;&#123; parentTree=this.getChildrenByPId(parentTree,list); &#125;); return treeList; &#125; /** * 根据某个父节点递归获取子节点 * @param parentTree 父节点 * @param list 全部节点 * @return */ public Tree getChildrenByPId(Tree parentTree,List&lt;Tree&gt; list)&#123; list.forEach((tree)-&gt;&#123; if(tree.getParentid().equals(parentTree.getId()))&#123; tree=getChildrenByPId(tree,list); parentTree.getChildren().add(tree); &#125; &#125;); return parentTree; &#125; &#125; Controller层@RestController@RequestMapping("/tree")public class TreeController &#123; @Autowired private TreeService treeService; @GetMapping("/list") public ResponseEntity&lt;List&lt;Tree&gt;&gt; selectTreeList()&#123; return ResponseEntity.ok(treeService.findTreeList()); &#125;&#125; 调试 源码地址：GitHub]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Mybatis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式唯一ID生成策略]]></title>
    <url>%2Fposts%2Fa1e7d1d4%2F</url>
    <content type="text"><![CDATA[为什么要使用分布式ID生成器？互联网应用中，某个表可能要占用很大的物理存储空间，为了解决该问题，使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用ID自增策略，则可能产生重复的ID，此时应该使用分布式ID生成策略来生成ID。 分布式ID的特点 全局唯一，在整个系统中不同模块之间表的主键是唯一的 有序递增性。 常用的分布式ID生成策略数据库主键自增策略优点： 能够保证主键唯一性 能够保证主键递增 此方法是数据库原有的功能，使用简单 数字化的，查询效率高 缺点： 自增的步长是固定的，缺乏安全性。如果订单表的主键是这种生成策略，恶意用户很容易窥见订单号的规则，这样就很容易知道你的订单在某段时间内的数量。 存在单点问题，如果数据库挂了，就没法生成 ID了; 数据库的压力大，高并发扛不住 UUIDUUID是指在一台机器在同一时间中生成的数字在所有机器中都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字UUID由以下几部分的组合：（1）当前日期和时间。（2）时钟序列。（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，以连字号分为五段形式的36个字符，示例：550e8400-e29b-41d4-a716-446655440000在JAVA的类库中已经提供了UUID的API UUID.randomUUID() 优点： 本地生成，性能好，没有高可用风险. 缺点： 不是有序的，无法保证是单调递增 长度过长，往往使用字符串表示，查询效率低 储存空间大 Snowflake（雪花算法）snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。 snowflake算法所生成的ID结构 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点： 简单高效，生成速度快，每秒能够产生26万ID左右。 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点： 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 snowflake Java实现： public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** * @param workerId * 工作机器ID * @param datacenterId * 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** * 获取下一个ID * * @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* * GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式ID</tag>
        <tag>snowflake雪花算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot+FastDFS实现文件上传]]></title>
    <url>%2Fposts%2Ffa2b9b65%2F</url>
    <content type="text"><![CDATA[将文件上传至fastDFS服务并将图片信息保存到MongoDB fastDFS服务器和MongoDB都是部署到Docker容器中 使用Docker下载并运行fastDFS镜像下载docker的fastDFS镜像：（该方法是直接运行 如果没有镜像源就下载） # docker run -d --restart=always --privileged=true --net=host --name=fastdfs -e IP=&lt;输入你的ip 如果是云服务器的话 请输入外网ip&gt; -e WEB_PORT=80 -v $&#123;HOME&#125;/fastdfs:/var/local/fdfs registry.cn-beijing.aliyuncs.com/tianzuo/fastdfs 检查fastDFS容器是否安装 # docker ps 以交互式的方式进入fastDFS容器 # docker exec -it &lt;容器ID&gt; /bin/bash 追加一个html文件,并将文件上传至fastDFS服务器 echo "hello fastDFS! "&gt;hello.htmlfdfs_test /etc/fdfs/client.conf upload hello.html 在浏览器中访问file url 成功！！ 项目中添加依赖pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springboot-fastdfs-filesystem&lt;/artifactId&gt; &lt;groupId&gt;com.ghjcloud&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ghjcloud&lt;/groupId&gt; &lt;artifactId&gt;springboot-fastDFS-fileSystem&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/net.oschina.zcx7878/fastdfs-client-java --&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类@SpringBootApplication@ComponentScan(basePackages=&#123;"com.ghjcloud.fastDFS.fileSystem.api","com.ghjcloud.fastDFS.fileSystem"&#125;)@EntityScan(basePackages="com.ghjcloud.fastDFS.fileSystem.model")public class fileSystemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(fileSystemApplication.class); &#125;&#125; 配置文件application.ymlspring: application: name: filesystem data: mongodb: database: filesystemdb uri: mongodb://root:root@你的ip:27017/?gssapiServiceName=mongodb #SpringMVC上传文件配置 servlet: multipart: #默认支持文件上传. enabled: true #支持文件写入磁盘. file-size-threshold: 0 # 上传文件的临时目录 location: # 最大支持文件大小 max-file-size: 4MB # 最大支持请求大小 max-request-size: 30MBserver: port: 8011filesystem: fastdfs: connect_timeout_in_seconds: 5 #http连接超时时间 network_timeout_in_seconds: 30 #tracker和storage网络通信超时时长 charset: UTF-8 #字符编码 tracker_servers: 你的ip:22122 #tracker服务器地址，多个 trackerServer中间以逗号分隔 实体类文件类 package com.ghjcloud.fastDFS.fileSystem.model;import lombok.Data;import lombok.ToString;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import java.util.Map;@Data@ToString@Document(collection = "filesystem")//mongodb数据库中的collection（类似于sql中的表）public class FileSystem &#123; @Id private String fileId; //文件请求路径 private String filePath; //文件大小 private long fileSize; //文件名称 private String fileName; //文件类型 private String fileType; //图片宽度 private int fileWidth; //图片高度 private int fileHeight; //用户id，用于授权 private String userId; //业务key private String businesskey; //业务标签 private String filetag; //文件元信息 private Map metadata;&#125; 请求响应返回类型 package com.ghjcloud.fastDFS.fileSystem.model;import lombok.AllArgsConstructor;import lombok.Data;@Data@AllArgsConstructorpublic class ResponseResult &#123; private String message; private int code; private Object data; &#125; 数据访问层package com.ghjcloud.fastDFS.fileSystem.repository;import com.ghjcloud.fastDFS.fileSystem.model.FileSystem;import org.springframework.data.mongodb.repository.MongoRepository;import org.springframework.stereotype.Repository;@Repositorypublic interface FileSystemRepository extends MongoRepository&lt;FileSystem,String&gt; &#123;&#125; 业务层package com.ghjcloud.fastDFS.fileSystem.service;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.ghjcloud.fastDFS.fileSystem.model.FileSystem;import com.ghjcloud.fastDFS.fileSystem.repository.FileSystemRepository;import org.apache.commons.lang3.StringUtils;import org.csource.common.MyException;import org.csource.fastdfs.*;import org.omg.CORBA.NameValuePair;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.multipart.MultipartFile;import java.io.IOException;import java.util.HashMap;@Service@Transactionalpublic class FileSystemService &#123; @Value(&quot;$&#123;filesystem.fastdfs.connect_timeout_in_seconds&#125;&quot;) int connect_timeout; @Value(&quot;$&#123;filesystem.fastdfs.network_timeout_in_seconds&#125;&quot;) int network_timeout; @Value(&quot;$&#123;filesystem.fastdfs.charset&#125;&quot;) String charset; @Value(&quot;$&#123;filesystem.fastdfs.tracker_servers&#125;&quot;) String tracker_servers; @Autowired private FileSystemRepository fileSystemRepository; /** * 文件上传并将文件信息存储到MongoDB * @param multipartFile 文件 * @param metadata 文件元信息 */ public String fileUpload(MultipartFile multipartFile,String metadata)&#123; this.initFastDFSConfig(); StorageClient1 storageClient1=this.getStorageClient(); String fileId=null; try &#123; byte[] bytes=multipartFile.getBytes(); String originalFilename=multipartFile.getOriginalFilename();//文件原始名称 String ext=originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)+1);//文件扩展名 fileId=storageClient1.upload_file1(bytes,ext,null); FileSystem fileSystem=new FileSystem(); fileSystem.setFileId(fileId); fileSystem.setFileSize(multipartFile.getSize()); fileSystem.setFilePath(fileId); fileSystem.setFileName(multipartFile.getName()); fileSystem.setFileType(multipartFile.getContentType()); if(StringUtils.isNotBlank(metadata))&#123; HashMap map=JSON.parseObject(metadata, HashMap.class); fileSystem.setMetadata(map); &#125; fileSystemRepository.save(fileSystem); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; return fileId; &#125; //获取storage客户端 public StorageClient1 getStorageClient()&#123; //初始化fastDFS this.initFastDFSConfig(); //定义TrackerClient,用于请求TrackerServer TrackerClient trackerClient=new TrackerClient(); try &#123; //连接tracker服务器 TrackerServer trackerServer=trackerClient.getConnection(); //获取storage服务器 StorageServer storageServer=trackerClient.getStoreStorage(trackerServer); //创建storage客户端 return new StorageClient1(trackerServer,storageServer); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; //初始化fastDFS private void initFastDFSConfig() &#123; try &#123; ClientGlobal.initByTrackers(tracker_servers); ClientGlobal.setG_network_timeout(network_timeout); ClientGlobal.setG_connect_timeout(connect_timeout); ClientGlobal.setG_charset(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125; springboot集成swagger2Swagger2配置类 package com.ghjcloud.fastDFS.fileSystem.api;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Configuration &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.ghjcloud.fastDFS")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("FastDFS分布式文件上传demo") .description("FastDFS分布式文件上传demo")// .termsOfServiceUrl("/") .version("1.0.0") .build(); &#125;&#125; api接口 package com.ghjcloud.fastDFS.fileSystem.api;import com.ghjcloud.fastDFS.fileSystem.model.ResponseResult;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;@Api(value = "文件上传",description = "文件上传接口")public interface FileSystemControllerApi &#123; @ApiOperation("文件上传") ResponseResult uploadFile(MultipartFile multipartFile, String metadata);&#125; controller层package com.ghjcloud.fastDFS.fileSystem.controller;import com.ghjcloud.fastDFS.fileSystem.api.FileSystemControllerApi;import com.ghjcloud.fastDFS.fileSystem.model.ResponseResult;import com.ghjcloud.fastDFS.fileSystem.service.FileSystemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;@RestController@RequestMapping("/file")public class SystemFileController implements FileSystemControllerApi &#123; @Autowired private FileSystemService fileSystemService; @Override @PostMapping("/upload") public ResponseResult uploadFile(@RequestParam("file")MultipartFile multipartFile, @RequestParam(value="metadat",required=false)String metadata)&#123; final String fileId=fileSystemService.fileUpload(multipartFile, metadata); return new ResponseResult("上传成功！",200,fileId); &#125;&#125; 测试1.启动项目访问 http://localhost:8011/swagger-ui.html 2.选择一张文件上传，并查看响应结果 3.在浏览器中访问上传到fastDFS服务器的图片 http://fastDFS服务器IP/group1/M00/00/00/wKhOCl12eceAORP3ACo7X7diV14748.jpg 4.检查数据是否存储到mongodb数据库 在表filesystem中多一条记录，并且_id和返回的data数据一致]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Spring Boot</tag>
        <tag>FastDFS</tag>
        <tag>MongoDB</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux上安装Logstash并将mysql中数据同步到elasticsearch索引库]]></title>
    <url>%2Fposts%2F21a8dc83%2F</url>
    <content type="text"><![CDATA[elasticsearch安装具体安装过程请看上一篇博客：elasticsearch安装 注：安装elasticsearch之前确保你的环境安装了JDK8及以上版本，elasticsearch版本和logstash版本要一致，我这里使用的都是6.5.0版本。 ruby安装由于logstash-input-jdbc插件是ruby编写的，所有本地需要ruby的运行环境 安装Gem,Ruby是一种脚本语言，Gem是基于Ruby的一些开发工具包 $ yum install gem 配置国内镜像源 $ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 查看是否修改成功：gem sources -l 更新source cache $ gem sources -u logstash安装 官网下载地址： https://www.elastic.co/cn/downloads/logstash 如果要下载其他版本可以点击past release,我这里下载的是6.5.0的版本 下载完成解压后将其复制到虚拟机的/usr/local/logstash目录下 检查logstash是否安装成功 首先进入 logstash的bin目录下执行： 权限不足： chmod 777 ./logstash $ ./logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos; logstash-input-jdbc插件安装$ chmod 777 /usr/local/logstash/logstash-6.5.0/logstash-6.5.0/vendor/jruby/bin/jruby $ ./logstash-plugin install logstash-input-jdbc 创建mysql数据库SET FOREIGN_KEY_CHECKS=0;-------- Table structure for `item`------DROP TABLE IF EXISTS `item`;CREATE TABLE `item` ( `id` bigint(20) NOT NULL, `title` varchar(255) NOT NULL, `category` varchar(255) NOT NULL, `brand` varchar(255) NOT NULL, `price` double NOT NULL, `img` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-------- Records of item------INSERT INTO `item` VALUES ('1110', '华为 G9 青春版 白色 移动联通电信4G手机 双卡双待', '手机', '华为', '2999', 'http://image.jd.com/13123.jpg');INSERT INTO `item` VALUES ('1111', '三星 Galaxy C5（SM-C5000）4GB+32GB 枫叶金 移动联通电信4G手机 双卡双待', '手机', '三星', '5999', 'http://image.jd.com/13123.jpg'); mysql.conf配置文件 将jdbc的驱动复制到虚拟机上，我的是在： /usr/local/logstash/logstash-6.5.0/mysql-connector-java-8.0.13.jar 在logstash的config目录下创建mysql.conf文件,配置如下： input &#123; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://你的ip：3306/shop_db?serverTimezone=GMT%2B8&quot; $url jdbc_user =&gt; &quot;root&quot; $用户名 jdbc_password =&gt; &quot;root&quot; $密码 jdbc_driver_library =&gt; &quot;/usr/local/logstash/logstash-6.5.0/mysql-connector-java-8.0.13.jar&quot; $jdbc驱动的位置 jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; $是否分页 jdbc_page_size =&gt; &quot;10&quot; $每页显示记录数 statement =&gt; &quot;select * from item&quot; $查询出来的数据要同步到索引 schedule =&gt; &quot;* * * * *&quot; $定时任务，每一分钟同步一次 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.78.10:9200&quot; $es地址，多个地址用逗号隔开 index =&gt; &quot;shop&quot; $索引名 document_id =&gt; &quot;%&#123;id&#125;&quot; $ _id document_type =&gt; &quot;item&quot; $类型 &#125; stdout &#123; codec =&gt; json_lines $以json格式输出 &#125;&#125; 注意：我这里用的是mysql8，url需要加上时区参数，jdbc-driver-class是com.mysql.cj.jdbc.Driver，不是com.mysql.jdbc.Driver 实现数据同步在bin目录下执行： $ ./logstash -f ../config/mysql.conf ../是返回上一级目录]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker上安装Elasticsearch]]></title>
    <url>%2Fposts%2Fd7ba9b14%2F</url>
    <content type="text"><![CDATA[Elasticsearch安装拉取镜像# docker pull ElasticSearch 创建并启动容器 清理内存： 释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）: syncecho 3 &gt; /proc/sys/vm/drop_caches 启动容器： # docker run -e ES_JAVA_OPTS="-Xms256m -Xmx256m" -d -p 9200:9200 -p 9300:9300 --name &lt;容器名称&gt; &lt;镜像ID&gt; ElasticSearch是用Java写的，它默认会占用2GB的堆内存空间，-e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;限制内存为256MB docker ps查看 docker logs![1569054370710](D:\blog\source\_posts\Docker上安装Elasticsearch\1569054370710.png) &lt;容器ID&gt;查看日志信息，可能会报如下错误（再次docker ps会发现elasticsearch没有启动） 解决方法： 切换到root用户修改配置sysctl.conf # vi /etc/sysctl.conf 添加配置： # vm.max_map_count=655360 并执行命令： # sysctl -p docker start &lt;容器ID&gt;重新启动elasticsearch，即可启动成功。 检查浏览器URL地址输入&lt;ip地址&gt;：9200，会出现如下JSON格式的数据。 Java 使用 9300 端口连接ES 会出现如下错误NoNodeAvailableException[None of the configured nodes are available:[&#123;#transport#‐1&#125;&#123;exvgJLR‐RlCNMJy‐hzKtnA&#125;&#123;xxxx&#125;&#123;xxxx&#125;]]at org.elasticsearch.client.transport.TransportClientNodesService.ensureNodes AreAvailableat org.elasticsearch.client.transport.TransportClientNodesService.executeat org.elasticsearch.client.transport.TransportProxyClient.execute 解决方法： 拷贝配置文件到宿主机（docker中的elasticsearch容器必须是启动的）： # docker cp &lt;容器ID&gt;:/usr/share/elasticsearch/config/elasticsearch.yml /usr/local/elasticsearch/elasticsearch.yml 停止elasticsearch容器并删除它 # docker stop &lt;容器ID&gt; 查看停止的容器： # docker ps -a 删除容器 # docker rm -f &lt;容器ID&gt; 重新创建容器，此时需要挂载文件 # docker run -di -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; --name=&lt;容器名称&gt; -p 9200:9200 -p 9300:9300 -v /usr/local/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.5.0 在/usr/local/elasticsearch/elasticsearch.yml文件中添加transport.host: 0.0.0.0，配置如下： cluster.name: "docker-cluster"network.host: 0.0.0.0transport.host: 0.0.0.0# minimum_master_nodes need to be explicitly set when bound on a public IP# set to 1 to allow single node clusters# Details: https://github.com/elastic/elasticsearch/pull/17288discovery.zen.minimum_master_nodes: 1#允许跨域http.cors.enabled: truehttp.cors.allow-origin: "*" 安装IK中文分词器 从github下载ik，下载地址：(注意：IK分词器的版本和elasticsearch的版本要一致) https://github.com/medcl/elasticsearch-analysis-ik/releases 下载解压复制到宿主机 /usr/local/elasticsearch目录下 进入/usr/local/elasticsearch`目录 # cd /usr/local/elasticsearch 复制到elasticsearch容器中 # docker cp elasticsearch-analysis-ik-6.5.0 &lt;容器ID&gt;:/usr/share/elasticsearch/plugins 重启elasticsearch容器 # docker restart &lt;容器ID&gt; 检查是否安装成功： PUT http://&lt;你的ip&gt;:9200/_analyze&#123; &quot;analyzer&quot;:&quot;ik_smart&quot;, &quot;text&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125; 结果如下： &#123; "tokens": [ &#123; "token": "中国", "start_offset": 0, "end_offset": 2, "type": "CN_WORD", "position": 0 &#125;, &#123; "token": "驻", "start_offset": 2, "end_offset": 3, "type": "CN_CHAR", "position": 1 &#125;, &#123; "token": "洛杉矶", "start_offset": 3, "end_offset": 6, "type": "CN_WORD", "position": 2 &#125;, &#123; "token": "领事馆", "start_offset": 6, "end_offset": 9, "type": "CN_WORD", "position": 3 &#125;, &#123; "token": "遭", "start_offset": 9, "end_offset": 10, "type": "CN_CHAR", "position": 4 &#125;, &#123; "token": "亚裔", "start_offset": 10, "end_offset": 12, "type": "CN_WORD", "position": 5 &#125;, &#123; "token": "男子", "start_offset": 12, "end_offset": 14, "type": "CN_WORD", "position": 6 &#125;, &#123; "token": "枪击", "start_offset": 14, "end_offset": 16, "type": "CN_WORD", "position": 7 &#125;, &#123; "token": "嫌犯", "start_offset": 17, "end_offset": 19, "type": "CN_WORD", "position": 8 &#125;, &#123; "token": "已", "start_offset": 19, "end_offset": 20, "type": "CN_CHAR", "position": 9 &#125;, &#123; "token": "自首", "start_offset": 20, "end_offset": 22, "type": "CN_WORD", "position": 10 &#125; ]&#125; 出现的问题及解决方法 cluster block exception： &#123; "error": &#123; "root_cause": [ &#123; "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125; ], "type": "cluster_block_exception", "reason": "blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];" &#125;, "status": 403&#125; 解决方法： PUT http://&lt;你的IP&gt;:9200/_all/_settings&#123; "index.blocks.read_only_allow_delete": null&#125;]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一异常处理]]></title>
    <url>%2Fposts%2Ff118268a%2F</url>
    <content type="text"><![CDATA[统一的响应结果类型​ 在实际的spring boot项目开发过程中，我们后端要返回统一的Json数据格式给前端，便于前端对数据的处理。通常情况下，后端返回给前端的数据类型都是包含操作代码、返回信息、操作是否成功字段，例如： /** * 统一的响应结果类 *///lombok注解@Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息&#125; 如果有其他字段需求，如时间戳、返回的类型可以对上面的统一响应结果类进行继承。例如： @Data@NoArgsConstructor@AllArgsConstructor@Getterpublic class ObjectResponseResult extends ResponseResult &#123; private Date date; private Object data; &#125; 自定义错误代码： 每个业务操作的异常使用异常代码去标识。 错误代码接口，里面定义三个基本的抽象方法。 public interface ResultCode &#123; //操作是否成功,true为成功，false操作失败 boolean success(); //操作代码 int code(); //提示信息 String message();&#125; 公共的错误代码枚举类，实现了错误代码接口，里面的三个字段和ResponseResult一致： @ToStringpublic enum CommonCode implements ResultCode &#123; SUCCESS(true,10000,"操作成功！"), FAIL(false,11111,"操作失败！"), SERVER_ERROR(false,11011,"抱歉，系统繁忙，请稍后重试！"), REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"), ARGS_ERROR(false,10003,"参数错误！"); ; //操作是否成功 boolean success; //操作代码 int code; //提示信息 String message; CommonCode(boolean success, int code, String message) &#123; this.success=success; this.code=code; this.message=message; &#125; @Override public boolean success() &#123; return success; &#125; @Override public int code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 为了方便拿到指自定义的错误代码枚举类中的信息，可以在ResponseResult类中添加构造方法,并且初始化两种响应结果成功和失败： @Data@ToString@Getter@NoArgsConstructor@AllArgsConstructorpublic class ResponseResult &#123; private Boolean success;//操作是否成功 private int code;//操作代码 private String message;//返回的信息 public ResponseResult(ResultCode resultCode)&#123; this.success=resultCode.success(); this.code=resultCode.code(); this.message=resultCode.message(); &#125; public static ResponseResult SUCCESS()&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; public static ResponseResult FAIL()&#123; return new ResponseResult(CommonCode.FAIL); &#125;&#125; 统一的异常处理系统对异常的处理使用统一的异常处理流程 自定义异常类型。 自定义错误代码及错误信息。 对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较 齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。 对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 RuntimeException类型（运行时异常）。 可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随 请求响应给客户端。 异常的类型 可预知的异常：程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，例如判断用户为空时，抛出自定义异常，异常的错误信息可以写“用户为空” 不可预知的异常：由SpringMVC统一捕获Exception类型的异常。 异常抛出及处理流程 在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 统一由异常捕获类捕获异常，并进行处理 捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误 信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为11011错误代码并响应给用户 将错误代码及错误信息以Json格式响应给用户。 可预知异常处理自定义异常类 ** * 自定义异常类（可预知的异常） */public class MyException extends RuntimeException &#123; ResultCode resultCode;//错误代码 public MyException(ResultCode resultCode)&#123; this.resultCode=resultCode; &#125; public ResultCode getResultCode()&#123; return resultCode; &#125;&#125; 抛出异常类 每次抛出自定义异常都要写：throw new MyException(错误代码);为了简便书写，可以将抛出的自定义异常进行封装 public class ExceptionCast &#123; //将抛出的自定义异常进行封装 public static void Cast(ResultCode resultCode)&#123; throw new MyException(resultCode); &#125;&#125; 异常捕获类 使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常 /** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125;&#125; 注：因为返回的结果为Json格式的数据，需要上@ResponseBody注解，如果不写@ResponseBody注解可以将@ControllerAdvice注解改为@RestControllerAdvice，@RestController=@Controller+@ResponseBody 异常处理测试： 在controller、service、dao中都可以抛出异常 @RestController@RequestMapping("/index")public class indexController &#123; @GetMapping("/&#123;id&#125;") public ResponseResult findById(@PathVariable String id)&#123; if(id.equals("123")&#123; ExceptionCast.Cast(CommonCode.FAIL); &#125; return ResponseResult.SUCCESS(); &#125;&#125; 使用postman测试，结果： Get:http://localhost:8888/index/1 &#123; "success": true, "code": 10000, "message": "操作成功！"&#125; Get:http://localhost:8888/index/123 &#123; "success": false, "code": 10003, "message": "参数错误！"&#125; 不可预知异常处理​ 当以put方式请求http://localhost:8888/index/1 时，SpringMVC会如下异常： org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported 具体的响应信息： &#123; "timestamp": "2019-08-12T13:44:21.910+0000", "status": 405, "error": "Method Not Allowed", "message": "Request method 'PUT' not supported", "trace": "xxxx..........", "path": "/index/1"&#125; 此时的响应信息前端是无法进行解析的。 在异常捕获类中添加对Exception类异常的捕获： //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); return new ResponseResult(CommonCode.SERVER_ERROR); &#125; 再进行测试，响应的结果如下： &#123; "success": false, "code": 11011, "message": "抱歉，系统繁忙，请稍后重试！"&#125; 虽然对SpringMVC报的异常进行捕获了，但是响应的结果都是“抱歉，系统繁忙，请稍后重试！”。 当我们以非Get方式请求http://localhost:8888/index/1 时，我们希望响应的结果是“请求方式错误！” 针对上面的问题其解决的方法是： 在map中配置Exception类和ResultCode（上述的错误代码类） 在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型和错误代码，如果存在错误代码则返回此错误代码，否则返回11011（“抱歉，系统繁忙，请稍后重试！”）错误。 具体实现如下： 在通用错误代码类CommonCode中添加请求方式错误异常。 REQUEST_METHOD_ERROR(false,10002,"请求方式错误！"); 在异常捕获类中定义map类型的异常，key为异常类型，value为错误代码，将SpingMVC抛出的异常类添加到map中，在捕获Exception类异常时取出map中的错误代码ResultCode，最后返回响应结果。捕获异常类完整代码： package com.myblog.exception;import com.google.common.collect.ImmutableMap;import com.myblog.model.response.CommonCode;import com.myblog.model.response.ResponseResult;import com.myblog.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.web.HttpRequestMethodNotSupportedException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.HashMap;import java.util.Map;/** * 统一异常捕获类 */@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER=LoggerFactory.getLogger(ExceptionCatch.class); //捕获MyException此类异常 @ExceptionHandler(MyException.class) @ResponseBody public ResponseResult myException(MyException myException)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",myException.getMessage()); ResultCode resultCode=myException.getResultCode(); return new ResponseResult(resultCode); &#125; static Map&lt;Class&lt;?extends Throwable&gt;,ResultCode&gt; exceptionMap=new HashMap&lt;&gt;(); //捕获Exception此类异常 @ExceptionHandler(Exception.class) @ResponseBody public ResponseResult Exception(Exception exception)&#123; //输出日志 LOGGER.error("捕获一个异常：&#123;&#125;",exception.getMessage()); ResultCode resultCode=exceptionMap.get(exception.getClass()); if(resultCode!=null)&#123; return new ResponseResult(resultCode); &#125; return new ResponseResult(CommonCode.SERVER_ERROR); &#125; //在这里加入一些基础的异常类型判断 static &#123; //springmvc报异常：org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'PUT' not supported，将HttpRequestMethodNotSupportedException添加到exceptionMap中。 exceptionMap.put(HttpRequestMethodNotSupportedException.class,CommonCode.REQUEST_METHOD_ERROR); &#125;&#125; 测试： 用PUT方式（或者其他非Get方式）请求：http://localhost:8888/index/1 响应结果： &#123; &quot;success&quot;: false, &quot;code&quot;: 10002, &quot;message&quot;: &quot;请求方式错误！&quot;&#125; ​]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象笔记]]></title>
    <url>%2Fposts%2F453087e5%2F</url>
    <content type="text"><![CDATA[面向对象类和对象类是模子，确定对象将会拥有的特征（属性）和行为（方法）； 对象是类的实例表现 ； 类是对象的类型； 对象是特定类型的数据； 属性和方法属性：对象具有的各种静态特征，可理解为 对象有什么; 方法：对象具有的各种动态行为，可理解为 对象能做什么； 类和对象的关系类： 抽象的概念； 模板 对象： 一个看得见、摸得着的具体实体 类 ——实例化——&gt;对象 对象实例化对象实例化的过程可以分为两部分： 声明对象 ： Student stu 实例化对象：new Student(); Student one=new Student(); 在栈内存中声明对象； 在堆内存中通过new关键字开辟一块新的对象空间； 通过赋值符号将堆中的内存地址存放到栈中的对象空间中； 通过对象名来操作相关对象的具体信息 构造方法public class Student&#123; public Student（）&#123; //TODO &#125;&#125; 构造方法与类同名且没有返回值,可以有参数也可以没有参数 只能在对象实例化的时候调用 当没有指定构造方法时，系统会自动添加无参的构造方法 当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法 一个类可以有多个构造方法 public class Student &#123; int id; String name; int age; public Student()&#123; this(1,"张三",10); System.out.println("无参构造函数"); &#125; public Student(int id, String name, int age) &#123; sayHi(); this.id=id; this.name=name; this.age=age; &#125; public Student(int id)&#123; this(); &#125; public void sayHi()&#123; System.out.println("hello,I am a student!"); &#125;&#125; 构造方法可以用this关键字调用其他构造方法，并且this关键字只能放在方法体的第一位 this关键字表示当前对象，this的使用： 调用成员属性，解决成员属性和局部变量同名冲突 调用成员方法 调用重载的构造方法 封装概念将类的某些信息隐藏在类内部，不允许外部程序直接访问 通过该类提供的方法来实现对隐藏信息的操作和访问 隐藏对象的信息 留出访问的接口 特点 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 封装的代码实现实现步骤 修改属性的可见性，设为private，使其只能在当前类中访问 创建getter/setter方法，设为public，用于属性的读写 在getter/setter方法中加入属性控制语句 public class Student &#123; private int id; private String name; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id=id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name=name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age=age; &#125;&#125; 包作用： 管理Java文件 解决同名文件冲突 定义包： package 包名； 必须放在Java源文件中的第一行； 一个Java源文件中只能有一个package语句； 包名全部英文小写； 命名方式：域名倒序+模块+功能 导入包： import 包名.类名； static关键字 static+属性 ——静态属性 static+方法 ——静态方法 static+类 ——不存在 static+方法内局部变量 ——不存在 静态成员随类加载产生，直至类销毁才回收； 静态方法 可以直接调用同类中的静态成员； 不可以直接调用同类中的非静态成员； 可以通过实例化对象后，对象调用的方式完全非静态成员调用。 代码块 通过{ }可以形成代码块 方法内的代码块称为：普通代码块 类中的代码块称为：构造代码块 构造代码块前加static：静态代码块 代码块执行顺序： 无论实例对象产生多少对象，静态代码块只执行一次； 构造代码块随实例化过程调用 普通代码块随方法调用执行 继承概念一种类与类之间的关系； 使用已存在的类（父类或者基类）定义作为基础建立新类（子类或者派生类）； 新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但是不能选择性地继承父类； 特点 利于代码复用 缩短开发周期 继承的关系 满足 A is a B的关系就可以形成继承关系；如： 猫、狗是动物——猫、狗继承自动物； 学生、老师是人——学生、老师继承自人。 实现继承使用extends实现继承 编写父类 class Animal&#123; //公共的属性和方法&#125; 编写子类，继承父类 class Dog extends Animal&#123; //子类特有的属性和方法&#125;class Cat extends Animal&#123; //子类特有的属性和方法&#125; 方法重写与重载方法重写的语法规则：返回类型、方法名、参数类型、顺序、个数都要和父类继承的方法相同 方法重写与重载的区别： 方法重写 方法重载 在满足继承关系的子类中 在同一个类中 方法名，参数个数、顺序、类型，返回值类型与父类相同 方法名相同 访问修饰符的限定范围大于等于父类方法 返回值类型、访问修饰符任意 访问修饰符 公有的：public 私有的：private 受保护的：protected 默认： 访问级别 访问控制修饰符 同类 同包 子类 不同的包 公开 public √ √ √ √ 受保护 protected √ √ √ – 默认 没有访问控制修饰符 √ √ – – 私有 private √ – – – 继承后的初始化顺序 父类静态成员 子类静态成员 父类对象构造 子类对象构造 super关键字子类访问父类成员： 访问父类成员方法： super.print(); 访问父类属性： super.name; 访问父类构造方法： super(); 注意： 子类的构造的过程中必须调用其父类的构造方法； 如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参构造方法； 如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译错误； 使用super调用父类指定构造方法，必须在子类的构造方法的第一行。 this和super的比较： this:当前类对象的引用 访问当前类的成员方法； 访问当前类的成员属性； 访问当前类的构造方法； 不能在静态方法中使用。 super：父类对象的引用 访问父类的成员方法； 访问父类的成员属性； 访问父类的构造方法； 不能在静态方法中使用。 构造方法调用时，super和this不能同时出现。 final关键字 修饰类表示不允许被继承，public final class A 或 final public class A 修饰方法不能被子类重写 final修饰的方法可以被继承 不能修饰构造方法 修饰变量表示不允许修改 方法内部的局部变量 》》在使用之前被初始化赋值即可 类中成员变量 》》只能在定义时或者构造代码块、构造方法中进行初始化设置 基本数据类型的变量 》》初始赋值之后不能更改 引用类型的变量 》》初始化之后不能再指向另一个对象，但是指向的对象的属性可以被修改。 可以配合static使用 使用final可以提高性能，但是会降低扩展性。 多态向上转型概念向上转型又叫自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类的对象可以赋值给父类的对象， 如：Animal dog=new Dog（）；//Dog类是Animal的子类 注：向上转型是安全的，因为任何子类都继承并接受了父类的方法。 应用 当一个子类对象向上转型父类类型后，就被当成了父类对象，所能调用的方法会减少，只能调用子类重写父类的方法以及父类派生的方法（如getter、setter方法），而不能调用子类独有的方法。 父类中静态方法是不允许被子类重写的 动态绑定多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调动该类的方法，两者相辅相成。 绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。 静态绑定：在程序运行前进行绑定（由编译器和链接程序远程的），也叫做前期绑定。 例如： //有一类Human，它派生出三个子类Chinese类、American类和British类，三个子类中都重写了父类中方法speak（）：void，在测试类中用静态绑定的方式调用方法speak（）；Chinese c=new Chinese();c.speak();American a=new American();a.speak();British b=new British();b.speak(); 这种调用方式是在代码里指定的，编译时编译器就知道c调用的是Chinese的speak（），a调用的是American的speak（）。 动态绑定：在程序运行期间由JVM根据对象的类型自动的判断应该调用哪个方法，也叫做后期绑定。 例如： //生成父类对象数组，数组长度为5Human[] human=new Human[5];int n;for(int i=0;i&lt;human.length;i++)&#123; n=(int)(Math.random()*3);//随机产生从0到2中一个数 switch（n）&#123; case 0：human[i]=new Chinese();break; case 1:huamn[i]=new Ameriican();break; case 2:huamn[i]=new British();break; &#125;&#125;//循环输出每个对象分别调用speak（）方法for(int i=0;i&lt;human.length;i++)&#123; human[i].speak();&#125; 此时，Human类中随机生成Chines类、American类和British类的对象，编译器不能根据代码直接确定调用哪个类中的speak（）方法，直到运行时才能根据产生的随机数n的值来确定human[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的speak（）方法，这就是动态绑定。 向下转型 向下转型是与向上转型相对的概念，它是用子类引用指向父类实例。 Animal a=new Dog();Dog d=(Dog)a; 向下转手，可以调用子类自己独有的方法 兄弟类之间不能进行强制类型转换。 虽然编译时不会报错，但是运行时会报 java.lang.ClassCastException的错误。 instanceof运算符instanceof运算符用来判断对象是否可满足某个特定类型实例特征。返回值为true/false。一般用于if语句中。 用instanceof运算符来判断对象是否可满足某个特定类型实例特征。 例如： //对象实例化People stu=new Student();People teacher=new Teacher();System.out.println(stu instance of Student);//trueSystem.out.println(stu instance of teacher);//falseSystem.out.println(stu instance of Object);//trueSystem.out.println(teacher instance of teahcer);//true 抽象类和抽象方法抽象类和抽象方法的声明格式： abstract class &lt;类名&gt;&#123; 成员变量； 方法（）&#123;方法体；&#125;//一般方法 abstract 方法（）；//抽象方法&#125; 特点： 抽象方法不允许直接实例化，换句话说抽象类不能创建对象，它只能作为其他类的父亲。但可以通过向上转型，指向实例化。 抽象方法只有声明，不能有实现，也就是仅有方法头，没有方法体和操作实现。 注意： 含有抽象方法的类，只能被定义为抽象类，也就是说抽象方法只能在抽象类中。 抽象类中不一定包含抽象方法，抽象类中可以没有抽象方法 抽象类中的成员方法可以包括一般方法和抽象方法。 抽象类不能实例化，即使抽象类里没有抽象方法，这个抽象类也不能创建实例， 抽象类的构造方法主要是用于被其子类调用。 一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现。 即使父类是具体的，但其子列也可以是抽象的。 abstract方法不能用static和private修饰；对于类，不能同时用final和abstract修饰，因为final关键字使得类不可继承，而abstract修饰的类如果不可以继承将没有任何意义。两只放一起，会起冲突。 接口特点接口声明格式： public interface &lt;接口名&gt;&#123; 抽象方法；&#125; 接口访问修饰符默认为public 接口中的方法全是抽象方法，接口中抽象方法可以不写abstract。 当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置为抽象类。 接口中可以包含常量，默认为 public static final String MSG="OK";//public static final String MSG="OK"； 其他类调用接口中的常量，接口名.常量名 默认方法和静态方法定义一个接口： public interface IUserDao &#123; void addUser(); default void findUser(String id)&#123; System.out.println("查询ID为"+id+"的用户"); &#125; static void updateUser()&#123; System.out.println("修改用户..."); &#125;&#125; 实现类： public class UserDao implements IUserDao &#123; @Override public void addUser() &#123; System.out.println("新增一个用户！"); &#125;&#125; 测试类中调用： public static void main(String[] args) &#123; UserDao userDao=new UserDao(); userDao.addUser(); userDao.findUser("10001"); IUserDao.updateUser(); &#125; 在JDK1.8之后，接口中可以通过关键字 default定义默认方法和关键字 static定义静态方法， 这两种方法有方法体，实现类可以不用实现它。实现类中可以重写默认方法，但是不能重写静态方法，默认方法只有实现类才能调用，而静态方法只能接口调用。 内部类public class Person &#123; public String name; public Heart getHeart()&#123; return new Heart(); &#125; public void getBeat()&#123; new Heart().beat(); &#125; public class Heart&#123; String name="张三"; public void beat()&#123; //System.out.println(name+"的心脏跳动"); System.out.println(Person.this.name+"的心脏跳动"); &#125; &#125; &#125; 外部测试方法 public static void main(String[] args) &#123; Person.Heart heart1=new Person().new Heart(); heart1.beat(); &#125; 成员内部类： 内部类在外部使用时，无法直接实例化，需要借助外部类信息才能完成实例化 内部类的访问修饰符可以任意，但是访问范围会受到影响 内部类可以直接访问外部类的成员；如果出现同名属性，优先访问内部类中定义的 可以使用外部类.this.成员的方式，访问外部类中同名的信息 外部类访问内部类信息，需要通过内部类实例，无法直接访问 内部类编译后 .class文件命名：外部类$内部类.class 静态内部类： 静态内部类中，只能直接访问外部类的静态方法/成员，如果需要调用非静态方法/成员，可以通过对象实例 获取静态内部类实例时，可以不依赖于外部类对象 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 当内部类属性与外部类属性同名时，默认直接调用内部类中的成员；如果需要访问外部类中的静态属性，则可以通过 外部类.属性 的方式；如果需要访问外部类中的非静态属性，则可以通过new 外部类（ ）.属性 的方式 方法内部类： 定义在方法内部，作用范围也在方法内 和方法内部成员使用规则一样，class前面不可以添加public、private、protected、static 类中不能包含静态成员 类中可以包含final、abstract修饰的成员 匿名内部类： 匿名内部类必须继承一个父类或者实现一个父接口。 匿名内部类没有类型名称、实例对象名称 编译后的文件命名：外部类$数字.class 无法使用private、protected、public、abstract、static 修饰 无法编写构造方法，可以添加静态代码块 不能出现静态成员 定义接口： public abstract class FlyAble&#123; public abstract void fly();&#125; 创建匿名内部类，并调用： public class Test&#123;public static void main(String[] args) &#123; /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; public void fly() &#123; System.out.println("我飞了~~~"); &#125; &#125;; //调用 fly方法,执行重写后的方法 f.fly(); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础(一)]]></title>
    <url>%2Fposts%2F15328330%2F</url>
    <content type="text"><![CDATA[Java简介JVM JVM（Java Virtual Machine），Java虚拟机 JVM是Java平台无关性实现的关键 Java程序的执行流程： JDK JDK（Java Development Kit），Java语言的软件开发工具包； 两个主要组件： -javac ——编译器，将源程序转为字节码文件 -java ——运行编译后的Java程序（.class后缀的） JRE JRE（Java Runtime Emnvironment），Java运行环境； 它包括JVM、Java核心类库和支持文件； 如果只需要运行Java程序，下载并安装JRE即可； 如果需要开发Java，需要下载JDK； JDK中附带有JRE JVM、JRE和JDK三者的关系 JRE=JVM+JavaSE标准类库 JDK=JRE+开发工具集（例如javac编译工具等） Java平台 Java SE: Java标准版 Java EE：Java企业版 Java ME: Java微型版 变量与常量标识符标识符的命名规则： 标识符可以由字符、数字、下划线（_）和美元符组成（$）,不能以数字开头； 标识符严格区分大小写； 标识符不能是Java的关键字和保留字； 保留字（reserved words）：是语言已经定义过的字，一些保留字可能没有相对应的语法，考虑到扩展性，为了向后兼容不能再将其作为变量名。const和goto是java的保留字。 所有的关键字都是小写 标识符的命名最好能够反映其作用； 变量变量的三个元素：变量类型、变量名和变量值 变量的命名规则： 满足标识符的命名规则； 符合驼峰法的命名规则； 尽量的简单，做到见名知意； 变量名长度没有限制。 类的命名规则： 满足Pascal命名法的规范； 数据类型数据类型包含：基本数据类型和引用数据类型。 基本数据类型： 数值型 整数类型（byte、short、int、long） 浮点类型（float、double） 字符型（char） 布尔型（boolean） 引用数据类型： 类（class） 接口（interface） 数组 基本数据类型 数据类型 说明 字节（1B=8bit） byte 字节型 1 short 短整型 2 int 整型 4 long 长整型 8 float 单精度浮点型 4 double 双精度浮点型 8 char 字符型 2 boolean 布尔型 1 整型字面值Java中有三种表示整数的方法：十进制、八进制、十六进制 进制表示： 八进制：以0开头，包括0-7的数字 ，如：021,073； 十六进制：以0x或者0X开头，包括0-9的数字及字母a-f，A-F，如：0x123,0xabcf，0XABCDFF。 浮点型字面值浮点型字面值默认情况下表示double类型，也可以在值后面加d或者D，如123.1246d、124.52D； 如表示float类型，则需要在字面值后面加f或者F，如20.15f、26.45F 字符型字面值字符型字面值使用单引号内的单个字符表示，如：’a’、’b’、’$’ 布尔型字面值布尔类型的字面值只能是true 和false； 字符串字面值字符串不属于基本类型，他属于类； 字符串字面值用双引号引起来的0个或多个字符；如：”hello”、” “ 、”123” 变量的定义变量类型 变量名=变量值； 基本数据类型变量的存储 局部变量（方法级）的存储方式：存储在栈内存中 int n=100;//定义一个整型的变量n并对它的值进行初始化 在内存的栈中开辟int类型大小的空间，将整型字面值100存储到开辟好的空间中，再将该空间起一个别名叫n； 数据类型转换类型转换分为自动类型转换和强制类型转换 自动类型（隐式类型）转换顺序： 强制类型转换：如果A类型的数据表示范围比B类型的大，则将A类型的值赋值给B类型，需要强制类型转换。 强制类型转换的格式：（数据类型）数值； double d=123.45;float f=(float)d; 常量定义常量： final 数据类型 常量名=常量值； 常量名最好使用大写，常量定义并初始化值后无法修改其常量值； final double PI=3.14; 运算符表达式表达式由运算符和操作数组成，如 5 num1 num1+num2 sum=num1+num2 运算符运算符包含：算数运算符、赋值运算符、关系运算符、逻辑运算符、条件运算符、位运算符 赋值运算符格式： 变量=表达式； 赋值运算符是从右往左运算的； 赋值运算符的左边不能是常量 例如： int n=3;//将3赋值给变量ndouble d;20.12=d;//错误写法，赋值运算符的左边不能是常量 复合赋值运算符 运算符 表达式 计算 结果（假设x=15） += x+=5 x=x+5 20 -= x-=5 x=x-5 10 *= x*=5 x=x*5 75 /= x/=5 x=x/5 3 %= x%=5 x=x%5 0 自增自减运算符 运算符 说明 ++ 自增1 – 自减1 表达式 执行方式 结果（a=1） b=++a; a=a+1;b=a a=2;b=2 b=a++; b=a;a=a+1; a=2;b=1; b=–a; a=a-1;b=a; a=0;b=0; b=a–; b=a;a=a-1; a=0;b=1; int a=5;int b=-a+++-5; //b=-5-5=-10;a=a++=6;a=5;int c=-(--a)+-5;//a=a-1=4;c=-4+(-5)=-9a=5;int d=--a+5; //a=a-1=4;d=4+5=9 算数运算符算数运算符主要用于进行基本的算数运算，如加、减、乘、除、求余、自增1和自减1； 操作符 描述 例子（A=10，B=20） + 加法 - 相加运算符两侧的值 A + B 等于 30 - 减法 - 左操作数减去右操作数 A – B 等于 -10 * 乘法 - 相乘操作符两侧的值 A * B等于200 / 除法 - 左操作数除以右操作数 B / A等于2 ％ 取余 - 左操作数除以右操作数的余数 B%A等于0 ++ 自增: 操作数的值增加1 B++ 或 ++B 等于 21（区别详见下文） – 自减: 操作数的值减少1 B– 或 –B 等于 19 关系运算符比较运算符用于判断两个数据的大小，如大于、小于等 运算符 含义 说明 实例 结果 &gt; 大于运算符 只支持左右两边操作数是数值类型。如果前面变量的值大于后面变量的值， 则返回 true。 2&gt;3 false &gt;= 大于或等于运算符 只支持左右两边操作数是数值类型。如果前面变量的值大于等于后面变量的值， 则返回 true。 4&gt;=2 true &lt; 小于运算符 只支持左右两边操作数是数值类型。如果前面变量的值小于后面变量的值，则返回 true。 2&lt;3 true &lt;= 小于或等于运算符 只支持左右两边操作数是数值类型。如果前面变量的值小于等于后面变量的值， 则返回 true。 4&lt;=2 false == 相等运算符 如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值相等，也都将返回 true。 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。Java也支持两个 boolean 类型的值进行比较。 4==4 97==’a’ 5.0==5 true==false true true true false != 不相等运算符 如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值不相等，也都将返回 true。 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 4!=2 true 逻辑运算符逻辑运算符用来连接一个或多个条件，判断这些条件是否成立。 逻辑运算符的操作数和结果是布尔类型 名称 运算符 表达式 与 &amp;&amp;或&amp; operator1&amp;&amp;operator2 或 ||或| operator1||operator2 非 ！ !operator1 逻辑”与”运算符：只要有一个操作数为false，结果也为false；操作数都为true时，结果才为true。 &amp;运算符 int a=3;boolean b=(3&gt;5)&amp;((a++)&lt;2); //b=false;a=4; &amp;&amp;运算符:又叫短路运算符，如果第一个表达式的值就能决定表达式最后的结果，运算符右边的表达式就不再计算。 int a=3;boolean b=(3&gt;5)&amp;&amp;((a++)&lt;2); //b=false;a=3;int c=5;boolean d=(5&gt;3)&amp;&amp;((c--)&lt;1);//d=false;c=4; 逻辑”或”运算：只要有一个操作数为ture，结果就为true；操作数都为false，结果为false。 |运算符 int a=3;boolean b=(3&lt;5)|((a++)&lt;2);//b=true;a=4; ||运算符:又叫短路运算符，如果第一个表达式的值就能决定表达式最后的结果，运算符右边的表达式就不再计算. int c=5;boolean d=(3&lt;5)||((a++)&lt;2); //d=true;c=5; 逻辑”非”运算符： ！运算符：对原条件进行取反 条件运算符Java中的条件运算符是三目运算符。 单目运算符：只对一个操作数进行运算，例如++，–； 双目运算符：需要对两个操作数进行运算，例如+、-、*、/ ； 格式：布尔表达式？表达式1：表达式2 当布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值； 运算符的优先级 优先级 运算符 简介 结合性 1 [ ]、.、( ) 方法调用，属性获取 从左向右 2 !、~、 ++、 – 一元运算符 从右向左 3 * 、/ 、% 乘、除、取模（余数） 从左向右 4 + 、 - 加减法 从左向右 5 &lt;&lt;、 &gt;&gt;、 &gt;&gt;&gt; 左位移、右位移、无符号右移 从左向右 6 &lt; 、&lt;= 、&gt;、 &gt;=、 instanceof 小于、小于等于、大于、大于等于， 对象类型判断是否属于同类型 从左向右 7 == 、!= 2个值是否相等，2个值是否不等于。 下面有详细的解释 从左向右 8 &amp; 按位与 从左向右 9 ^ 按位异或 从左向右 10 | 按位或 从左向右 11 &amp;&amp; 短路与 从左向右 12 || 短路或 从左向右 13 ?: 条件运算符 从右向左 14 =、 += 、-= 、*= 、/=、 %=、 &amp;=、 |=、 ^=、 &lt;、&lt;= 、&gt;、&gt;= 、&gt;&gt;= 混合赋值运算符 从右向左 流程控制三大流程控制语句：顺序、选择和循环 选择结构 if-else结构 if（条件）&#123; 语句；&#125;else&#123; 语句；&#125; 多重if结构 if(表达式1)&#123; 语句1；&#125;else if(表达式2)&#123; 语句2；&#125;else if(表达式3)&#123; 语句3；&#125;...else&#123; 语句n；&#125; 嵌套if结构 if(表达式1)&#123; 语句1； if(表达式2)&#123; 语句2； if（表达式3）&#123; 语句3； &#125; &#125;&#125;else&#123; 语句；&#125; switch结构 switch(表达式)&#123; case 常量表达式1： 语句1；break； case 常量表达式2： 语句2；break； .... default: 语句n；&#125; if和switch的区别： if结构： 判断条件是布尔类型 判断条件是一个范围 switch结构： 判断条件是常量值 循环结构 while循环：先对条件进行判断然后运行方法体。 while(循环条件)&#123; 语句；&#125;while（循环条件）；//死循环 do-while循环 do&#123; 语句；&#125;while(循环条件); 循环至少执行一次，循环条件后的分号不能丢。 for循环 for(表达式1；表达式2；表达式3)&#123; 语句；&#125; 局部变量只在定义它的大括号内有效。 嵌套循环 计算：1！+2！+3！+4！的结果 int s=1,sum=0; for(int i=1;i&lt;=4;i++)&#123; s=1; for(int j=1;j&lt;=i;j++)&#123; s=s*j; &#125; sum=sum+s; &#125; System.out.println(sum); break语句 跳出当前循环； break语句可以结束当前循环的执行； 执行break语句后，循环体中位于break语句后面的语句就不会执行； 在多重循环中，break语句只向外跳一层。 continue语句 continue语句只能用在循环里； continue语句只结束当前循环的执行，但是要继续下一次循环的执行； 求：1+3+5+7+9 int sum=0;for(int i=1;i&lt;=9;i++)&#123; if(i%2==0)continue; sum=sum+i;&#125;System.out.println(sum); 数组数组是相同类型的数据按照顺序组成的一种引用数据类型。 数组声明语法格式： 数组类型[] 数组名;或 数组类型 数组名[]; int[] arr;int arr[];char[] chArr;String strArr[]; 数组创建语法格式一：先声明后创建 数组类型[ ] 数组名； 数组名=new 数组类型[数组长度]； //创建一个长度为10的整型数组int arr;arr=new int[10]; 语法格式二：声明的同时创建数组 数据类型[] 数组名=new 数组类型[数组长度]；或者 数据类型 数组名[]=new 数组类型[数组长度]； int[] arr=new int[10];int arr2[]=new int[20]; 数组在内存的存储数组会被分配连续的内存空间。 int a[]=new int[5]; 在内存中分配5个连续的内存空间，并且初始值为0； 数组的初始化声明数组的同时给数组赋值，叫做数组的初始化。 int arr[]=&#123;1,2,3,10&#125;; 数组元素的引用语法格式： 数组名[下标]； 下标是从0开始的； 方法方法的声明语法格式： 访问修饰符 返回类型 方法名（参数列表）&#123; 方法体&#125; 方法的分类根据方法是否带参数、是否有返回值，可分为四类： 无参无返回值方法； 无参有返回值方法； 带参无返回值方法； 带参有返回值方法； 方法重载方法名相同，参数列表不同 可变参数列表 可变参数一定是方法中的最后一个参数； 数组可以传递给可变参数的方法，反之不行； 在重载中，含有可变参数的方法是最后被调用的]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
