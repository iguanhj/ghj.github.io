<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java面向对象笔记 | Guan</title><meta name="description" content="Java面向对象笔记"><meta name="keywords" content="Java"><meta name="author" content="Guan"><meta name="copyright" content="Guan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon2.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://guanhongjie.coding.me/posts/453087e5/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java面向对象笔记"><meta name="twitter:description" content="Java面向对象笔记"><meta name="twitter:image" content="http://image.sky7.club/images/blog/java2.PNG"><meta property="og:type" content="article"><meta property="og:title" content="Java面向对象笔记"><meta property="og:url" content="http://guanhongjie.coding.me/posts/453087e5/"><meta property="og:site_name" content="Guan"><meta property="og:description" content="Java面向对象笔记"><meta property="og:image" content="http://image.sky7.club/images/blog/java2.PNG"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="手写实现ArrayList、LinkedList和HashMap" href="http://guanhongjie.coding.me/posts/1a0e1ee8/"><link rel="next" title="Java基础(一)" href="http://guanhongjie.coding.me/posts/15328330/"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d631fca1b9b4a6d4b1f6b0d5db747f27";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-148517345-1', 'auto');
ga('send', 'pageview');
</script><meta name="google-site-verification" content="vABtl4jO4DKE4n_zVQS4fH2a4Klk2axuQdL9xSK47U0"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://iguanhj.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象"><span class="toc-number">1.1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性和方法"><span class="toc-number">1.2.</span> <span class="toc-text">属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象的关系"><span class="toc-number">1.3.</span> <span class="toc-text">类和对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象实例化"><span class="toc-number">1.4.</span> <span class="toc-text">对象实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">1.5.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装的代码实现"><span class="toc-number">2.3.</span> <span class="toc-text">封装的代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包"><span class="toc-number">2.4.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字"><span class="toc-number">2.5.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">2.6.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码块"><span class="toc-number">2.7.</span> <span class="toc-text">代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-1"><span class="toc-number">3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承的关系"><span class="toc-number">3.3.</span> <span class="toc-text">继承的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现继承"><span class="toc-number">3.4.</span> <span class="toc-text">实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重写与重载"><span class="toc-number">3.5.</span> <span class="toc-text">方法重写与重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问修饰符"><span class="toc-number">3.6.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承后的初始化顺序"><span class="toc-number">3.7.</span> <span class="toc-text">继承后的初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super关键字"><span class="toc-number">3.8.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final关键字"><span class="toc-number">3.9.</span> <span class="toc-text">final关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#向上转型"><span class="toc-number">4.1.</span> <span class="toc-text">向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用"><span class="toc-number">4.1.2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态绑定"><span class="toc-number">4.1.3.</span> <span class="toc-text">动态绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向下转型"><span class="toc-number">4.2.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof运算符"><span class="toc-number">4.3.</span> <span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类和抽象方法"><span class="toc-number">4.4.</span> <span class="toc-text">抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">4.5.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认方法和静态方法"><span class="toc-number">4.5.2.</span> <span class="toc-text">默认方法和静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">4.6.</span> <span class="toc-text">内部类</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://picsum.photos/id/1047/3264/1448)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Guan</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href=" /music/ "><i class="fa-fw  fa fa-music"></i><span> 音乐 </span></a></li><li><a class="site-page" href=" /tools/ "><i class="fa-fw  fa fa-bars"></i><span> 工具 </span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/ "><i class="fa-fw  fa fa-coffee"></i><span> 留言板</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java面向对象笔记</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-01-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-10-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java-SE/">Java SE</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类是模子，确定对象将会拥有的特征（属性）和行为（方法）；</p>
<p>对象是类的实例表现 ；</p>
<p>类是对象的类型；</p>
<p>对象是特定类型的数据；</p>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>属性：对象具有的各种静态特征，可理解为 <code>对象有什么</code>;</p>
<p>方法：对象具有的各种动态行为，可理解为 <code>对象能做什么</code>；</p>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>类： </p>
<ul>
<li>抽象的概念；</li>
<li>模板</li>
</ul>
<p>对象：</p>
<ul>
<li>一个看得见、摸得着的具体实体</li>
</ul>
<p>类 ——实例化——&gt;对象</p>
<h3 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h3><p>对象实例化的过程可以分为两部分：</p>
<ul>
<li>声明对象 ： Student stu</li>
<li>实例化对象：new Student();</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student one=<span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<ol>
<li>在栈内存中声明对象；</li>
<li>在堆内存中通过new关键字开辟一块新的对象空间；</li>
<li>通过赋值符号将堆中的内存地址存放到栈中的对象空间中；</li>
<li>通过对象名来操作相关对象的具体信息</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Student（）&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>构造方法与类同名且没有返回值,可以有参数也可以没有参数</code></li>
<li><code>只能在对象实例化的时候调用</code></li>
<li><code>当没有指定构造方法时，系统会自动添加无参的构造方法</code></li>
<li><code>当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法</code></li>
<li><code>一个类可以有多个构造方法</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">10</span>);</span><br><span class="line">       </span><br><span class="line">		System.out.println(<span class="string">"无参构造函数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		sayHi();</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,I am a student!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法可以用this关键字调用其他构造方法，并且this关键字只能放在方法体的第一位</p>
<p>this关键字表示当前对象，this的使用：</p>
<ul>
<li>调用成员属性，解决成员属性和局部变量同名冲突</li>
<li>调用成员方法</li>
<li>调用重载的构造方法</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问</p>
<p>通过该类提供的方法来实现对隐藏信息的操作和访问</p>
<p>隐藏对象的信息</p>
<p>留出访问的接口</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>只能通过规定的方法访问数据</li>
<li>隐藏类的实例细节，方便修改和实现</li>
</ol>
<h3 id="封装的代码实现"><a href="#封装的代码实现" class="headerlink" title="封装的代码实现"></a>封装的代码实现</h3><p>实现步骤</p>
<ol>
<li>修改属性的可见性，设为private，使其只能在当前类中访问</li>
<li>创建getter/setter方法，设为public，用于属性的读写</li>
<li>在getter/setter方法中加入属性控制语句 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>作用：</p>
<ol>
<li>管理Java文件</li>
<li>解决同名文件冲突</li>
</ol>
<p>定义包： <code>package 包名；</code></p>
<blockquote>
<ol>
<li>必须放在Java源文件中的第一行；</li>
<li>一个Java源文件中只能有一个package语句；</li>
<li>包名全部英文小写；</li>
<li>命名方式：域名倒序+模块+功能</li>
</ol>
</blockquote>
<p>导入包： <code>import 包名.类名；</code></p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><ol>
<li>static+属性   ——静态属性</li>
<li>static+方法 ——静态方法</li>
<li>static+类  ——不存在</li>
<li>static+方法内局部变量 ——不存在</li>
</ol>
<p>静态成员随类加载产生，直至类销毁才回收；</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ol>
<li>可以直接调用同类中的静态成员；</li>
<li>不可以直接调用同类中的非静态成员；</li>
<li>可以通过实例化对象后，对象调用的方式完全非静态成员调用。</li>
</ol>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ol>
<li>通过{ }可以形成代码块</li>
<li>方法内的代码块称为：普通代码块</li>
<li>类中的代码块称为：构造代码块</li>
<li>构造代码块前加static：静态代码块</li>
</ol>
<p>代码块执行顺序：</p>
<ol>
<li>无论实例对象产生多少对象，静态代码块只执行一次；</li>
<li>构造代码块随实例化过程调用</li>
<li>普通代码块随方法调用执行</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一种类与类之间的关系；</p>
<p>使用已存在的类（<code>父类或者基类</code>）定义作为基础建立新类（<code>子类或者派生类</code>）；</p>
<p>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但是不能选择性地继承父类；</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>利于代码复用</li>
<li>缩短开发周期</li>
</ol>
<h3 id="继承的关系"><a href="#继承的关系" class="headerlink" title="继承的关系"></a>继承的关系</h3><p> 满足 <code>A is a B</code>的关系就可以形成继承关系；如：</p>
<p>猫、狗是动物——猫、狗继承自动物；</p>
<p>学生、老师是人——学生、老师继承自人。</p>
<h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><p>使用extends实现继承</p>
<ol>
<li><p>编写父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//公共的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写子类，继承父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//子类特有的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">     <span class="comment">//子类特有的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="方法重写与重载"><a href="#方法重写与重载" class="headerlink" title="方法重写与重载"></a>方法重写与重载</h3><p>方法重写的语法规则：<code>返回类型、方法名、参数类型、顺序、个数都要和父类继承的方法相同</code></p>
<p>方法重写与重载的区别：</p>
<table>
<thead>
<tr>
<th align="center">方法重写</th>
<th align="center">方法重载</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在满足继承关系的子类中</td>
<td align="center">在同一个类中</td>
</tr>
<tr>
<td align="center">方法名，参数个数、顺序、类型，返回值类型与父类相同</td>
<td align="center">方法名相同</td>
</tr>
<tr>
<td align="center">访问修饰符的限定范围大于等于父类方法</td>
<td align="center">返回值类型、访问修饰符任意</td>
</tr>
</tbody></table>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li><p>公有的：public</p>
</li>
<li><p>私有的：private</p>
</li>
<li><p>受保护的：protected</p>
</li>
<li><p>默认：</p>
<table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类</strong></th>
<th><strong>不同的包</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公开</td>
<td>public</td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>–</strong></td>
</tr>
<tr>
<td>默认</td>
<td>没有访问控制修饰符</td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>–</strong></td>
<td><strong>–</strong></td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td><strong>√</strong></td>
<td><strong>–</strong></td>
<td><strong>–</strong></td>
<td><strong>–</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="继承后的初始化顺序"><a href="#继承后的初始化顺序" class="headerlink" title="继承后的初始化顺序"></a>继承后的初始化顺序</h3><ol>
<li>父类静态成员</li>
<li>子类静态成员</li>
<li>父类对象构造</li>
<li>子类对象构造</li>
</ol>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>子类访问父类成员：</p>
<ul>
<li>访问父类成员方法： <code>super.print();</code></li>
<li>访问父类属性： <code>super.name;</code></li>
<li>访问父类构造方法： <code>super();</code></li>
</ul>
<p>注意：</p>
<ol>
<li>子类的构造的过程中必须调用其父类的构造方法；</li>
<li>如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参构造方法；</li>
<li>如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译错误；</li>
<li>使用super调用父类指定构造方法，必须在子类的构造方法的第一行。</li>
</ol>
<p><strong>this和super的比较：</strong></p>
<p>this:当前类对象的引用</p>
<ul>
<li>访问当前类的成员方法；</li>
<li>访问当前类的成员属性；</li>
<li>访问当前类的构造方法；</li>
<li>不能在静态方法中使用。</li>
</ul>
<p>super：父类对象的引用</p>
<ul>
<li>访问父类的成员方法；</li>
<li>访问父类的成员属性；</li>
<li>访问父类的构造方法；</li>
<li>不能在静态方法中使用。</li>
</ul>
<p><code>构造方法调用时，super和this不能同时出现。</code></p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol>
<li><p>修饰类表示不允许被继承，public final class  A 或 final public class A</p>
</li>
<li><p>修饰方法不能被子类重写</p>
<ul>
<li>final修饰的方法可以被继承</li>
<li>不能修饰构造方法</li>
</ul>
</li>
<li><p>修饰变量表示不允许修改</p>
<ul>
<li>方法内部的局部变量   》》在使用之前被初始化赋值即可</li>
<li>类中成员变量   》》只能在定义时或者构造代码块、构造方法中进行初始化设置</li>
<li>基本数据类型的变量 》》初始赋值之后不能更改</li>
<li>引用类型的变量 》》初始化之后不能再指向另一个对象，但是指向的对象的属性可以被修改。</li>
</ul>
</li>
<li><p>可以配合static使用</p>
</li>
<li><p>使用final可以提高性能，但是会降低扩展性。</p>
</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>向上转型又叫自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类的对象可以赋值给父类的对象，</p>
<p>如：Animal dog=new Dog（）；//Dog类是Animal的子类</p>
<p>注：向上转型是安全的，因为任何子类都继承并接受了父类的方法。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li>当一个子类对象向上转型父类类型后，就被当成了父类对象，所能调用的方法会减少，只能调用子类重写父类的方法以及父类派生的方法（如getter、setter方法），而不能调用子类独有的方法。</li>
<li>父类中静态方法是不允许被子类重写的</li>
</ol>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调动该类的方法，两者相辅相成。</p>
<p>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。</p>
<p><code>静态绑定</code>：在程序运行前进行绑定（由编译器和链接程序远程的），也叫做前期绑定。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有一类Human，它派生出三个子类Chinese类、American类和British类，三个子类中都重写了父类中方法speak（）：void，在测试类中用静态绑定的方式调用方法speak（）；</span></span><br><span class="line">Chinese c=<span class="keyword">new</span> Chinese();</span><br><span class="line">c.speak();</span><br><span class="line">American a=<span class="keyword">new</span> American();</span><br><span class="line">a.speak();</span><br><span class="line">British b=<span class="keyword">new</span> British();</span><br><span class="line">b.speak();</span><br></pre></td></tr></table></figure>

<p>这种调用方式是在代码里指定的，编译时编译器就知道c调用的是Chinese的speak（），a调用的是American的speak（）。</p>
<p><code>动态绑定</code>：在程序运行期间由JVM根据对象的类型自动的判断应该调用哪个方法，也叫做后期绑定。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成父类对象数组，数组长度为5</span></span><br><span class="line">Human[] human=<span class="keyword">new</span> Human[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;human.length;i++)&#123;</span><br><span class="line">    n=(<span class="keyword">int</span>)(Math.random()*<span class="number">3</span>);<span class="comment">//随机产生从0到2中一个数</span></span><br><span class="line">    <span class="keyword">switch</span>（n）&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>：human[i]=<span class="keyword">new</span> Chinese();<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:huamn[i]=<span class="keyword">new</span> Ameriican();<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:huamn[i]=<span class="keyword">new</span> British();<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环输出每个对象分别调用speak（）方法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;human.length;i++)&#123;</span><br><span class="line">    human[i].speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，Human类中随机生成Chines类、American类和British类的对象，编译器不能根据代码直接确定调用哪个类中的speak（）方法，直到运行时才能根据产生的随机数n的值来确定human[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的speak（）方法，这就是动态绑定。</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><ol>
<li><p>向下转型是与向上转型相对的概念，它是用子类引用指向父类实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal a=new Dog();</span><br><span class="line">Dog d=(Dog)a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下转手，可以调用子类自己独有的方法</p>
</li>
<li><p>兄弟类之间不能进行强制类型转换。</p>
<p>虽然编译时不会报错，但是运行时会报 <code>java.lang.ClassCastException</code>的错误。</p>
</li>
</ol>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p>instanceof运算符用来判断对象是否可满足某个特定类型实例特征。返回值为true/false。一般用于if语句中。</p>
<p>用instanceof运算符来判断对象是否可满足某个特定类型实例特征。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象实例化</span></span><br><span class="line">People stu=<span class="keyword">new</span> Student();</span><br><span class="line">People teacher=<span class="keyword">new</span> Teacher();</span><br><span class="line">System.out.println(stu instance of Student);<span class="comment">//true</span></span><br><span class="line">System.out.println(stu instance of teacher);<span class="comment">//false</span></span><br><span class="line">System.out.println(stu instance of Object);<span class="comment">//true</span></span><br><span class="line">System.out.println(teacher instance of teahcer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><p>抽象类和抽象方法的声明格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> &lt;类名&gt;</span>&#123;</span><br><span class="line">    成员变量；</span><br><span class="line">    方法（）&#123;方法体；&#125;<span class="comment">//一般方法</span></span><br><span class="line">    <span class="keyword">abstract</span> 方法（）；<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>抽象方法不允许直接实例化，换句话说抽象类不能创建对象，它只能作为其他类的父亲。但可以通过向上转型，指向实例化。</li>
<li>抽象方法只有声明，不能有实现，也就是仅有方法头，没有方法体和操作实现。</li>
</ol>
<p>注意：</p>
<ol>
<li><p>含有抽象方法的类，只能被定义为抽象类，也就是说抽象方法只能在抽象类中。</p>
</li>
<li><p>抽象类中不一定包含抽象方法，抽象类中可以没有抽象方法</p>
</li>
<li><p>抽象类中的成员方法可以包括一般方法和抽象方法。</p>
</li>
<li><p>抽象类不能实例化，即使抽象类里没有抽象方法，这个抽象类也不能创建实例，</p>
<p>抽象类的构造方法主要是用于被其子类调用。</p>
</li>
<li><p>一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现。</p>
</li>
<li><p>即使父类是具体的，但其子列也可以是抽象的。</p>
</li>
<li><p>abstract方法不能用static和private修饰；对于类，不能同时用final和abstract修饰，因为final关键字使得类不可继承，而abstract修饰的类如果不可以继承将没有任何意义。两只放一起，会起冲突。</p>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>接口声明格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> &lt;接口名&gt;</span>&#123;</span><br><span class="line">    抽象方法；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>接口访问修饰符默认为public</p>
</li>
<li><p>接口中的方法全是抽象方法，接口中抽象方法可以不写abstract。</p>
</li>
<li><p>当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置为抽象类。</p>
</li>
<li><p>接口中可以包含常量，默认为 public static final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String MSG=<span class="string">"OK"</span>;<span class="comment">//public static final String MSG="OK"；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他类调用接口中的常量，接口名.常量名</p>
</li>
</ol>
<h4 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h4><p>定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">findUser</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"查询ID为"</span>+id+<span class="string">"的用户"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"修改用户..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"新增一个用户！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类中调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UserDao userDao=<span class="keyword">new</span> UserDao();</span><br><span class="line">		userDao.addUser();</span><br><span class="line">		userDao.findUser(<span class="string">"10001"</span>);</span><br><span class="line">		IUserDao.updateUser();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.8之后，接口中可以通过关键字 <code>default</code>定义默认方法和关键字 <code>static</code>定义静态方法， 这两种方法有方法体，实现类可以不用实现它。实现类中可以重写默认方法，但是不能重写静态方法，默认方法只有实现类才能调用，而静态方法只能接口调用。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Heart <span class="title">getHeart</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Heart();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBeat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Heart().beat();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;</span><br><span class="line">		String name=<span class="string">"张三"</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//System.out.println(name+"的心脏跳动");</span></span><br><span class="line">            System.out.println(Person.<span class="keyword">this</span>.name+<span class="string">"的心脏跳动"</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person.Heart heart1=<span class="keyword">new</span> Person().new Heart();</span><br><span class="line">		heart1.beat();	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类：</p>
<ol>
<li>内部类在外部使用时，无法直接实例化，需要借助外部类信息才能完成实例化</li>
<li>内部类的访问修饰符可以任意，但是访问范围会受到影响</li>
<li>内部类可以直接访问外部类的成员；如果出现同名属性，优先访问内部类中定义的</li>
<li>可以使用外部类.this.成员的方式，访问外部类中同名的信息</li>
<li>外部类访问内部类信息，需要通过内部类实例，无法直接访问</li>
<li>内部类编译后 .class文件命名：外部类$内部类.class</li>
</ol>
<p>静态内部类：</p>
<ol>
<li>静态内部类中，只能直接访问外部类的静态方法/成员，如果需要调用非静态方法/成员，可以通过对象实例</li>
<li>获取静态内部类实例时，可以不依赖于外部类对象</li>
<li>可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员</li>
<li>当内部类属性与外部类属性同名时，默认直接调用内部类中的成员；如果需要访问外部类中的静态属性，则可以通过 外部类.属性 的方式；如果需要访问外部类中的非静态属性，则可以通过new 外部类（ ）.属性 的方式</li>
</ol>
<p>方法内部类：</p>
<ol>
<li>定义在方法内部，作用范围也在方法内</li>
<li>和方法内部成员使用规则一样，class前面不可以添加public、private、protected、static</li>
<li>类中不能包含静态成员</li>
<li>类中可以包含final、abstract修饰的成员</li>
</ol>
<p>匿名内部类：</p>
<ol>
<li>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</li>
<li>匿名内部类没有类型名称、实例对象名称</li>
<li>编译后的文件命名：外部类$数字.class</li>
<li>无法使用private、protected、public、abstract、static 修饰</li>
<li>无法编写构造方法，可以添加静态代码块</li>
<li>不能出现静态成员</li>
</ol>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建匿名内部类，并调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span></span><br><span class="line"><span class="comment">        2.等号左边:是多态赋值,接口类型引用指向子类对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        FlyAble  f = <span class="keyword">new</span> FlyAble()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我飞了~~~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 fly方法,执行重写后的方法</span></span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Guan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://guanhongjie.coding.me/posts/453087e5/">http://guanhongjie.coding.me/posts/453087e5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://guanhongjie.coding.me">Guan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a></div><div class="post_share"><div class="social-share" data-image="http://image.sky7.club/images/blog/java2.PNG" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechatreward.jpg"><div class="post-qr-code__desc">微信</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1a0e1ee8/"><img class="prev_cover lozad" data-src="http://image.sky7.club/blogimg/jihe.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>手写实现ArrayList、LinkedList和HashMap</span></div></a></div><div class="next-post pull-right"><a href="/posts/15328330/"><img class="next_cover lozad" data-src="http://image.sky7.club/images/blog/java2.PNG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java基础(一)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'ol3kFl6JgskTuxhP1fWvVP5l-MdYXbMMI',
  appKey:'PYECWvlXA1HTIoFDU3CKFQnn',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div id="footer"><div class="copyright">&copy;2019 By Guan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://iguanhj.github.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></section><div class=" " id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">面向对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类和对象"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">类和对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#属性和方法"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">属性和方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类和对象的关系"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">类和对象的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#对象实例化"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">对象实例化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#构造方法"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">构造方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#封装"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">封装</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#概念"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#特点"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#封装的代码实现"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">封装的代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#包"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">包</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static关键字"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">static关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#静态方法"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">静态方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码块"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">代码块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#继承"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">继承</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#概念-1"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#特点-1"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承的关系"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">继承的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实现继承"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">实现继承</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法重写与重载"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">方法重写与重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#访问修饰符"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">访问修饰符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承后的初始化顺序"><span class="toc_mobile_items-number">3.7.</span> <span class="toc_mobile_items-text">继承后的初始化顺序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#super关键字"><span class="toc_mobile_items-number">3.8.</span> <span class="toc_mobile_items-text">super关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#final关键字"><span class="toc_mobile_items-number">3.9.</span> <span class="toc_mobile_items-text">final关键字</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#多态"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">多态</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#向上转型"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">向上转型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#概念-2"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#应用"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">应用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态绑定"><span class="toc_mobile_items-number">4.1.3.</span> <span class="toc_mobile_items-text">动态绑定</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#向下转型"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">向下转型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#instanceof运算符"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">instanceof运算符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抽象类和抽象方法"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">抽象类和抽象方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#接口"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">接口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#特点-2"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#默认方法和静态方法"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">默认方法和静态方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内部类"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">内部类</span></a></li></ol></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script color="0,0,255" opacity="0.7" zindex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>